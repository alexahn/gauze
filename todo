[x] generalized mutation interface
[x] configure query and mutations to interact with a query builder (like knex)
[x] expose schema to http
[x] setup context with db connection
[ ] setup context with user authentication
[ ] build a react app to test out the architecture
[ ] dependency injection
	[ ] refactor everything later if we want the ability to thoroughly test every module
[x] might need to make our own rest handler because we need to know when queries/mutations are finished
[x] rename connection to database
[x] module naming and organizing conventions
	[x] barrel modules
[x] rename database/database.js to database/knex.js
[x] rename interface directories to interfaces
[ ] relationships modeling
	[x] create a table to track relationships
	[x] implement relationship traversal via queries
	[x] implement relationship creation and deletion via mutations
		[-] join update and join delete doesn't seem to work in sqlite3, maybe try postgresql
		[x] brute force this by re-using read method and using where in (works in sqlite and postgresql)
	[ ] see if there a way to not forfeit foreign key constraints without having to create different tables for every type of relationship
		[ ] look into constraints to manage one to one, one to many, and many to one relationships
	[ ] have an admin method to track objects that have no relationships
[x] logging
	[x] visually simple logging based on level, topic, and message
		[x] stack based prefixing based on variable inputs to write
	[-] look into using console.group and console.groupEnd as an alternative to manually managing a stack prefix
	[x] use the logger in all the modules
	[x] clean up console.log usage
[x] reorganize the structure module
	[x] entities should be the highest directory level
[ ] look into programmatically generating graphql and sql structures from an abstract structure
[ ] look into deepcopy for graphql schema and type extension
	[ ] update graphql type names and descriptions to prefix or suffix with database, system, or user
[ ] type naming constraints
	[ ] cap table name to 255 characters
	[ ] cap graphql type name to 255 characters
[x] rename constants and variables in interfaces/mutations
[x] use constants defined in structures for table names for database models
[x] formalize query and mutations to look the same
	[x] split relationship type for query and mutation
	[x] re-expose query and mutation at entity level for nested queries and mutations
	[x] dynamically configure relationships, sub-queries, and sub-mutations by creating an abstraction
[x] shell / repl
[ ] command directory
	[ ] yargs?
	[x] terminal
	[x] server
	[ ] manage?
[x] realms (database, system, user) should be written by using the exposed interface for the layer below
	[x] forces any circular dependencies to be made apparent
	[x] use structure as $structure
	[x] use kernel as $kernel
	[x] use database as $database
[x] update graphql type names to use two underscores as a separator
[x] change relationship column names (from to from_type, to to to_type)
[x] enable variables for graphql server
[x] investigate why orderBy is not working in knex with sqlite3
	[x] order_nulls breaks the query
	[x] remove order_nulls for now until we find a solution
[x] figure out a way to enable debugging of queries easily
	[x] toString method allows every query to be printed
	[x] put all sql queries into constants so they can be re-used
	[x] add new environment variables: GAUZE_DEBUG_SQL, GAUZE_DEBUG_GRAPHQL
[x] add primary key to database models and use them for the default order
	[x] add primary key to sql structures
[ ] refactor logger to make it functional (e.g. stop mutating arrays and have functions return fully transformed items)
	[x] remove the magic string by fully implementing the correct stack marking algorithm
		[x] turns out we don't need to change the code, we can just do a null checkl
[x] testing
	[x] set up example queries that line up with the seeded data
	[x] test create, read, update, delete
	[x] test relationships
	[x] test nested mutation and queries
[x] force sqlite file to be made at the root directory
[x] programmatically manage created_at, updated_at, deleted_at, id
	[x] add protected fields to sql structures
	[x] delete the fields prior to constructing a sql query
	[x] have the model handle them
	[x] add serializers to fields
[x] add graphql shell
	[x] add an execute function for database and system realms in the terminal
[ ] soft delete
[ ] rename columns in relationship table
	[ ] example: _id to gauze__relationship__id
	[ ] example: _from_id to gauze__relationship__from_id
	[ ] we want to avoid naming conflicts on joins with builtin tables
[x] refactor system controllers to use graphql queries/mutations against the database interface
	[x] might as well set it up now
	[x] copy existing system controllers and interface to database
	[x] will help with serializer logic as well since the serializers will all run at the database level
	[x] where in and where not in exposed to database graphql
		[x] where not in takes precedence over where in
	[x] where in and where not in exposed to system graphql
	[ ] implement error visibility (right now it's a little rough if something goes wrong)
[x] move server.js into command
[ ] turn kernel into a proper stack
	[x] kernel/controllers/class.js
	[x] kernel/models/class.js
	[ ] kernel/interfaces
[x] serialize / deserialize
	[x] call serialize and deserialize from controllers, but defined on models
[x] update constants in interface to use the subdirectory (e.g. add GRAPHQL)
[ ] convert operations from strings to source object for debugging purposes
	[ ] https://github.com/graphql/graphql-js/blob/main/src/language/source.ts
[x] update update and delete mutations to accept limit, offset, and order arguments 
[x] grep -r \~ .
	[x] vim shows ~ at the end of a file so sometimes it can blend in
[x] change serializers to be generators that accept a field name
[ ] basic authentication and session management so we have the concept of a user
	[ ] account table (look at how passport and nextjs auth create their tables)
	[ ] proxy graphiql via server
	[ ] use a higher level http server (express, fastify, koa, etc) ?
		[ ] url and routes
[x] move execute from terminal to kernel/shell
	[x] import execute from kernel and use in system models
	[x] refactor inputs to execute to make it pretty (e.g. context instead of contextValue, variables insead of variableValues)
	[ ] import execute from kernel and use in tests
[ ] add a _description attribute to every module so that the codebase can be explored via the repl
	[ ] always add the field at the end of every module definition so it shows up at the bottom in the repl
[ ] move object destructuring for database model inputs into the function itself (for debugging purposes when we want to log the entire input)
	[x] database models
[ ] add logging to system models
[x] fix structure names in graphql.js and sql.js files
	[x] GRAPHQL_DATABASE_RELATIONSHIP_ATTRIBUTES_FIELDS_ARRAY_STRUCTURE shoudl be ATTRIBUTES_FIELDS_ARRAY_GRAPHQL_DATABASE_RELATIONSHIP_STRUCTURE
		[x] maybe introduce a double underscore convention to seperate the namespace from the item?
			[x] ATTRIBUTES_FIELDS_ARRAY__GRAPHQL__DATABASE__RELATIONSHIP__STRUCTURE ?
				[x] does seem more clear
	[x] sql.js
	[x] graphql.js
	[x] database/interfaces/operations
	[x] schemas
	[x] queries and mutations
	[x] kernel/shell
	[x] kernel/logger
	[x] kernel/cache
[ ] start thinking about kernel/src or kernel/source
	[ ] bootstrap new project by using commands that use the source code
		[ ] should have commands to create new entities
			[ ] base everything off structures
[ ] permissions and authorization
	[-] row based security (postgresql)?
		[-] seems like it is technically complex because we'd need to authenticate every user to postgresql
		[-] the application code isn't complex, but the database tuning and management would be
		[-] the example policies i could find also don't seem to be that flexible, and it might be hard to set them up without duplicating relationship data across entities
	[ ] maybe some kind of bit field if we want to be efficient?
	[ ] simple white and black list permissions
		[ ] system permissions
		[ ] user permissions
	[ ] system whitelist and blacklist tables
	[ ] user whitelist and blacklist tables
	[ ] structure information for default mode for table
[ ] cached where in and cached where not in exposed to database graphql
	[ ] value is a string key that is a key to a value in cache
	[ ] hook up lru cache to system and database
[ ] accept a query parameter to simulate user id
	[ ] allows us to work on permission/authorization layer without having a user table
