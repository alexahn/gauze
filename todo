[x] generalized mutation interface
[x] configure query and mutations to interact with a query builder (like knex)
[x] expose schema to http
[x] setup context with db connection
[ ] setup context with user authentication
[ ] build a react app to test out the architecture
[ ] dependency injection
	[ ] refactor everything later if we want the ability to thoroughly test every module
[x] might need to make our own rest handler because we need to know when queries/mutations are finished
[x] rename connection to database
[x] module naming and organizing conventions
	[x] barrel modules
[x] rename database/database.js to database/knex.js
[x] rename interface directories to interfaces
[ ] relationships modelling
	[ ] create a table to track relationships
		[ ] look into constraints to manage one to one, one to many, and many to one relationships
	[ ] implement relationship traversal via queries
	[ ] implement relationship creation and deletion via mutations
	[ ] see if there a way to not forfeit foreign key constraints without having to create different tables for every type of relationship
[x] logging
	[x] visually simple logging based on level, topic, and message
		[x] stack based prefixing based on variable inputs to write
	[ ] look into using console.group and console.groupEnd as an alternative to manually managing a stack prefix
	[ ] use the logger in all the modules
[x] reorganize the structure module
	[x] entities should be the highest directory level
[ ] look into programmatically generating graphql and sql structures from an abstract structure
[ ] look into deepcopy for graphql schema and type extension
	[ ] update graphql type names and descriptions to prefix or suffix with database, system, or user
[ ] type naming constraints
	[ ] cap table name to 255 characters
	[ ] cap graphql type name to 255 characters
[ ] rename constants and variables in interfaces/mutations
[ ] use constants defined in structures for table names for database models
