[x] generalized mutation interface
[x] configure query and mutations to interact with a query builder (like knex)
[x] expose schema to http
[x] setup context with db connection
[ ] setup context with user authentication
[ ] build a react app to test out the architecture
[ ] dependency injection
	[ ] refactor everything later if we want the ability to thoroughly test every module
[x] might need to make our own rest handler because we need to know when queries/mutations are finished
[x] rename connection to database
[x] module naming and organizing conventions
	[x] barrel modules
[x] rename database/database.js to database/knex.js
[x] rename interface directories to interfaces
[ ] relationships modeling
	[x] create a table to track relationships
	[x] implement relationship traversal via queries
	[x] implement relationship creation and deletion via mutations
		[-] join update and join delete doesn't seem to work in sqlite3, maybe try postgresql
		[x] brute force this by re-using read method and using where in (works in sqlite and postgresql)
	[ ] see if there a way to not forfeit foreign key constraints without having to create different tables for every type of relationship
		[ ] look into constraints to manage one to one, one to many, and many to one relationships
	[ ] have an admin method to track objects that have no relationships
[x] logging
	[x] visually simple logging based on level, topic, and message
		[x] stack based prefixing based on variable inputs to write
	[-] look into using console.group and console.groupEnd as an alternative to manually managing a stack prefix
	[x] use the logger in all the modules
	[x] clean up console.log usage
[x] reorganize the structure module
	[x] entities should be the highest directory level
[ ] look into programmatically generating graphql and sql structures from an abstract structure
[ ] look into deepcopy for graphql schema and type extension
	[ ] update graphql type names and descriptions to prefix or suffix with database, system, or user
[ ] type naming constraints
	[ ] cap table name to 255 characters
	[ ] cap graphql type name to 255 characters
[x] rename constants and variables in interfaces/mutations
[x] use constants defined in structures for table names for database models
[x] formalize query and mutations to look the same
	[x] split relationship type for query and mutation
	[x] re-expose query and mutation at entity level for nested queries and mutations
	[x] dynamically configure relationships, sub-queries, and sub-mutations by creating an abstraction
[x] shell / repl
[ ] command directory
	[ ] yargs?
	[x] terminal
	[ ] server
	[ ] manage?
[ ] permissions and authorization
	[-] row based security (postgresql)?
		[-] seems like it is technically complex because we'd need to authenticate every user to postgresql
		[-] the application code isn't complex, but the database tuning and management would be
		[-] the example policies i could find also don't seem to be that flexible, and it might be hard to set them up without duplicating relationship data across entities
	[ ] maybe some kind of bit field if we want to be efficient?
	[ ] simple white and black list permissions
		[ ] system permissions
		[ ] user permissions
[ ] url and routes
[x] realms (database, system, user) should be written by using the exposed interface for the layer below
	[x] forces any circular dependencies to be made apparent
	[x] use structure as $structure
	[x] use kernel as $kernel
	[x] use database as $database
[ ] bootstrap new project by using commands
	[ ] should have commands to create new entities
[x] update graphql type names to use two underscores as a separator
[x] change relationship column names (from to from_type, to to to_type)
[x] enable variables for graphql server
[ ] use a higher level http server (express, fastify, koa, etc)
[x] investigate why orderBy is not working in knex with sqlite3
	[x] order_nulls breaks the query
	[x] remove order_nulls for now until we find a solution
[x] figure out a way to enable debugging of queries easily
	[x] toString method allows every query to be printed
	[x] put all sql queries into constants so they can be re-used
	[x] add new environment variables: GAUZE_DEBUG_SQL, GAUZE_DEBUG_GRAPHQL
[x] add primary key to database models and use them for the default order
	[x] add primary key to sql structures
[ ] refactor logger to make it functional (e.g. stop mutating arrays and have functions return fully transformed items)
	[ ] remove the magic string by fully implementing the correct stack marking algorithm
[ ] testing
	[x] set up example queries that line up with the seeded data
	[x] test create, read, update, delete
	[x] test relationships
	[ ] test nested mutation and queries
[x] force sqlite file to be made at the root directory
[ ] programmatically manage created_at, updated_at, deleted_at
	[ ] delete the fields prior to constructing a sql query
	[ ] have the model handle them
