[x] generalized mutation interface
[x] configure query and mutations to interact with a query builder (like knex)
[x] expose schema to http
[x] setup context with db connection
[x] setup context with user authentication
[ ] dependency injection
	[ ] refactor everything later if we want the ability to thoroughly test every module
[x] might need to make our own rest handler because we need to know when queries/mutations are finished
[x] rename connection to database
[x] module naming and organizing conventions
	[x] barrel modules
[x] rename database/database.js to database/knex.js
[x] rename interface directories to interfaces
[x] relationships modeling
	[x] create a table to track relationships
	[x] implement relationship traversal via queries
	[x] implement relationship creation and deletion via mutations
		[-] join update and join delete doesn't seem to work in sqlite3, maybe try postgresql
		[x] brute force this by re-using read method and using where in (works in sqlite and postgresql)
	[-] see if there a way to not forfeit foreign key constraints without having to create different tables for every type of relationship
		[x] look into constraints to manage one to one, one to many, and many to one relationships
			[x] we will have to handle this from the application level
[x] logging
	[x] visually simple logging based on level, topic, and message
		[x] stack based prefixing based on variable inputs to write
	[-] look into using console.group and console.groupEnd as an alternative to manually managing a stack prefix
	[x] use the logger in all the modules
	[x] clean up console.log usage
[x] reorganize the structure module
	[x] entities should be the highest directory level
[-] look into deepcopy for graphql schema and type extension
	[x] just hard copy the graphql definitions
	[-] update graphql type names and descriptions to prefix or suffix with database, system, or user
		[x] too tedious, better to re-use the underlying unified type
[x] rename constants and variables in interfaces/mutations
[x] use constants defined in structures for table names for database models
[x] formalize query and mutations to look the same
	[x] split relationship type for query and mutation
	[x] re-expose query and mutation at entity level for nested queries and mutations
	[x] dynamically configure relationships, sub-queries, and sub-mutations by creating an abstraction
[x] shell / repl
[x] realms (database, system, user) should be written by using the exposed interface for the layer below
	[x] forces any circular dependencies to be made apparent
	[x] use structure as $structure
	[x] use kernel as $kernel
	[x] use database as $database
[x] update graphql type names to use two underscores as a separator
[x] change relationship column names (from to from_type, to to to_type)
[x] enable variables for graphql server
[x] investigate why orderBy is not working in knex with sqlite3
	[x] order_nulls breaks the query
	[x] remove order_nulls for now until we find a solution
[x] figure out a way to enable debugging of queries easily
	[x] toString method allows every query to be printed
	[x] put all sql queries into constants so they can be re-used
	[x] add new environment variables: GAUZE_DEBUG_SQL, GAUZE_DEBUG_GRAPHQL
[x] add primary key to database models and use them for the default order
	[x] add primary key to sql structures
[-] refactor logger to make it functional (e.g. stop mutating arrays and have functions return fully transformed items)
	[x] remove the magic string by fully implementing the correct stack marking algorithm
		[x] turns out we don't need to change the code, we can just do a null checkl
[x] testing
	[x] set up example queries that line up with the seeded data
	[x] test create, read, update, delete
	[x] test relationships
	[x] test nested mutation and queries
[x] force sqlite file to be made at the root directory
[x] programmatically manage created_at, updated_at, deleted_at, id
	[x] add protected fields to sql structures
	[x] delete the fields prior to constructing a sql query
	[x] have the model handle them
	[x] add serializers to fields
[x] add graphql shell
	[x] add an execute function for database and system realms in the terminal
[x] refactor system controllers to use graphql queries/mutations against the database interface
	[x] might as well set it up now
	[x] copy existing system controllers and interface to database
	[x] will help with serializer logic as well since the serializers will all run at the database level
	[x] where in and where not in exposed to database graphql
		[x] where not in takes precedence over where in
	[x] where in and where not in exposed to system graphql
	[x] implement error visibility (right now it's a little rough if something goes wrong)
[x] move server.js into command
[x] serialize / deserialize
	[x] call serialize and deserialize from controllers, but defined on models
[x] update constants in interface to use the subdirectory (e.g. add GRAPHQL)
[ ] convert operations from strings to source object for debugging purposes
	[ ] https://github.com/graphql/graphql-js/blob/main/src/language/source.ts
[x] update update and delete mutations to accept limit, offset, and order arguments 
[x] grep -r \~ .
	[x] vim shows ~ at the end of a file so sometimes it can blend in
[x] change serializers to be generators that accept a field name
[x] move execute from terminal to kernel/shell
	[x] import execute from kernel and use in system models
	[x] refactor inputs to execute to make it pretty (e.g. context instead of contextValue, variables insead of variableValues)
	[x] import execute from kernel and use in tests
[ ] add a _description attribute to every module so that the codebase can be explored via the repl
	[ ] always add the field at the end of every module definition so it shows up at the bottom in the repl
[x] move object destructuring for database model inputs into the function itself (for debugging purposes when we want to log the entire input)
	[x] database models
[x] add logging to system models
[x] fix structure names in graphql.js and sql.js files
	[x] GRAPHQL_DATABASE_RELATIONSHIP_ATTRIBUTES_FIELDS_ARRAY_STRUCTURE shoudl be ATTRIBUTES_FIELDS_ARRAY_GRAPHQL_DATABASE_RELATIONSHIP_STRUCTURE
		[x] maybe introduce a double underscore convention to seperate the namespace from the item?
			[x] ATTRIBUTES_FIELDS_ARRAY__GRAPHQL__DATABASE__RELATIONSHIP__STRUCTURE ?
				[x] does seem more clear
	[x] sql.js
	[x] graphql.js
	[x] database/interfaces/operations
	[x] schemas
	[x] queries and mutations
	[x] kernel/shell
	[x] kernel/logger
	[x] kernel/cache
[x] rename columns in relationship table
	[x] example: _id to gauze__relationship__id
	[x] example: _from_id to gauze__relationship__from_id
	[x] we want to avoid naming conflicts on joins with builtin tables
	[x] use as precedent for new builtin tables (e.g. whitelist and blacklist tables)
[x] format graphql to make it consisten
	[x] time to switch to prettier? (https://prettier.io/docs/en/index.html)
[x] permissions and authorization
	[-] row based security (postgresql)?
		[-] seems like it is technically complex because we'd need to authenticate every user to postgresql
		[-] the application code isn't complex, but the database tuning and management would be
		[-] the example policies i could find also don't seem to be that flexible, and it might be hard to set them up without duplicating relationship data across entities
	[-] maybe some kind of bit field if we want to be efficient?
		[x] just cache the access control rows in memory if necessary
	[x] simple white and black list permissions
		[x] subcategorized by realm
	[x] whitelist and blacklist tables
	[x] structure information for default mode for methods (e.g. private or public)
	[x] blacklist and whitelist structures
	[x] blacklist and whitelist database models, controllers, and interface
[x] accept a query parameter to simulate user id
	[x] allows us to work on permission/authorization layer without having a user table
	[x] agent_id is exposed for all queries and mutations to simulate an agent
[x] add parent argument to database graphql queries and mutations
	[x] it should have a structure like:  { _metadata: { id, type } }
	[x] we need this to pass in the source (e.g. parent) from the system to honor relationships
[x] think about realm organization
	[x] might make more sense if system had an account, and application had a user
	[x] might make more sense if reality had a person, and story had a character
	[x] system can host applications and reality can host stories?
	[x] introduce concept of application
		[x] application realm interacts with user
	[x] system realm now interacts with account
	[x] add environment realm
	[x] for now system will represent the initial application (we can rename it later)
[x] update tables to use uuids so we can one shot bindings
	[x] 00000000-0000-0000-0000-000000000001 format for seed data
[x] create protected fields and update protected fields?
	[x] do we need to enforce not being able to change some fields after they are set?
		[x] split all protected fields to be implemented as pre serializer middleware
[x] proper names for entities and gauze files generated from kernel
[ ] turn kernel into a proper stack
	[x] kernel/controllers/class.js
	[x] kernel/models/class.js
	[ ] kernel/interfaces
		[ ] manage cache, logging, shell, infrastructure, etc
[x] start thinking about kernel/src or kernel/source
	[x] bootstrap new project by using commands that use the source code
		[x] should have commands to create new entities
			[-] base everything off structures
				[x] base everything off abstract atoms
			[x] look into programmatically generating graphql and sql structures from an abstract structure
				[ ] look into doing ast parsing and some table management data structures to programmatically generate migration files
	[x] create abstract structures
	[x] move entity1 and entity2 into kernel/src/migrations to make it easier for development
		[x] remove later once we can generate entities
		[-] move these migrations to structure?
	[x] base structure in kernel
	[x] base database model, controller, and interface
	[x] base system model, controller, and interface
	[x] fuse base_entity and base_gauze as base
	[ ] add gauze.json as a config file for the gauze cli (which will keep track of gauze base models and developer entities)
	[x] yargs cli for project
		[x] run server to use kernel server application
		[x] run terminal to use kernel terminal application
		[x] create, read, update, and delete to use kernel manager application
		[x] command directory
			[x] yargs?
			[x] terminal
			[x] server
			[x] create project
			[ ] read project
			[ ] update project
			[x] create entity
			[x] read entity (see todo below)
			[x] update entity
			[x] delete entity
		[ ] align environment variables with cli commands
	[-] centralize all zsh/bash scripts under the root bin directory?
		[-] or maybe have src/kernel/bin?
			[-] better to have a root level directory that is the interface with the outer operating system
		[x] maybe src/kernel/bin is better because the copied code will be self-contained
			[x] migrate root bin to kernel/bin
	[x] gauze cli (from node_modules), gauze-project cli (from bootstrapped project)
		[x] implemented as a subcommand for the gauze cli to proxy into the project cli
	[x] reorder export order in module files so that internal files are first
	[x] move base classes to the kernel
[ ] have read command manually construct a list of files and directories and intersect with the results from find
	[ ] kind of problematic when we just use find because an entity might contain another entity's name inside it
		[ ] e.g. hello_entity and hello_entity_world
[x] refactor server application to use kernel graphql shell execute
[x] update schema files to use $structure instead of directly importing
[-] group protected fields by method for sql structures
	[x] protected fields are now handled via pre_serializer middlewares
[x] refactor schema to use interface entities
	[x] add new files to base kernel
[x] refactor all exports to use the same naming convention (need two underscores instead of one in a lot of places)
[-] use es6 map for lru cache (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
	[x] refactored the lru cache but the performance seems worse
[x] copy the date graphql scalar so we have one less dependency
[x] sub categorize internal gauze commands and user commands
	[x] add example user command (so they can write their own webserver for example)
[ ] polish commands and manager application
[x] set up migrations for ezuag and ytitne
[x] set up seed data for ezuag and ytitne
[x] merge system models into one (there is no reason to have multiple)
[ ] naming convention refactor (update according to all rules)
	[x] double underscore for module namespacing hierarchy
	[ ] only use upper snake case for global constants and module exports (convert in function const to lower snake case)
[x] rename all kernel model methods to be underscore prefixed
	[x] refactor database models so that they have create, read, update, delete methods that proxy to the kernel method
		[x] allows for people to extend the models however they want, while preserving core internal logic
[x] update create operations to also create a whitelist entry
[x] isolated tests
	[x] make ytitne self-relational
	[x] don't depend on seed data for tests
		[x] will still depend on tables existing because we aren't programmatically generating migration files
	[x] combinatorially try most system states
		[x] need a consise way to write these tests, the current way is too heavy
			[x] write a way to define tests by treating the interface(s) as functions
			[x] make a steps loader and steps runner
		[x] tests for access control
		[x] creating relationships (should only be possible to create relationships for things the agent can access)
[x] use import.meta.filename instead of parsing import.meta.url
[x] add mandatory input guards in controllers (or into the type definition?)
	[x] as an example, attributes can currently be null right now, which causes an error
	[x] tried to do it through graphql type definitions but it is a pain in the ass because it treats the new type as a different type
		[x] the error message that graphql returns isn't exceptionally useful, so we can just throw our own error
[x] prevent update/delete from working with an empty where query? there is no reason to update everything a user has access to
	[x] added guards to database kernel model to check that where is provided
	[ ] think about how to make this prettier later
[x] logging strategy so we can see the entire access control pipeline from beginning to end
	[x] just prefix the message with something like 'access'
[x] move sql table name to abstract entities
[x] move graphql meta type to abstract entities (the meta type is not a name that is encoded within the schema, but a framework identifier)
[x] refactor structure/resolvers to use abstract entities so we can reduce the surface area of the staging layers
	[x] delete resolver staging files
[ ] refactor kernel models to have elegant function signatures
	[ ] should probably group things together to have better conceptual clarity instead of abusing positional arguments
[x] prevent particular types of data from being created, such as relationships on relationships
	[x] gauze internal models should be siloed as much as possible
	[x] perform checks for entity_type, and agent_type for internal models
[x] update system model create method to do policy checking just like other system model methods
	[x] null entity_id in whitelist means the whitelist applies to the entire collection for the particular method
[ ] optimizations for high performance
	[ ] have a look up data structure/table that maps the table name in the database to a readable name
		[ ] table names are limited to 4 characters in the database
	[ ] have a look up data structure/table that maps the method name in field values to a readable value
		[ ] methods are limited to 4 characters in the database
	[ ] have a look up data structure/table that maps the realm name in field values to a readable value
		[ ] realms are limited to 4 characters in the database
[x] rework workspace entities
	[x] rename entity1 to entity
		[x] remove relationship from entity to entity2
		[x] rework seed data
	[x] rename entity2 to gauze (internal)
		[x] remove relationship from gauze to entity1
		[x] rework seed data
	[x] reconfigure stages
		[x] will need to have a truncated stage for the last two stages so that teardown doesn't crash
		[x] after successful setup copy the new stages to the last two stages
[x] move all existence checks to the edge (e.g. attributes, where, where_in, etc)
	[x] to interfaces
[-] change _access_execute in system model to not throw errors
[-] make a database directory per steps directory that has initialization for the database
	[-] run the steps in the database directory against the database schema
	[-] we should be able to one shot initialization for every test case using the database interface
	[-] currently, we are relying on the seed data for whitelist to enable creating models for two fixed agent ids
	[x] or we can set up independent seed sources, so that test data has its own reliable seed structure
		[x] tests now use src/database/seeds/test
[x] prevent relationships from being made if the from and to are not connected
	[x] use structure definition
	[x] rename DATABASE_RELATIONSHIP_STRUCTURE to proper naming convention
		[x] don't import DATABASE_RELATIONSHIP_STRUCTURE directly from schemas
	[-] rename structure/relationships to structure/connections
		[x] moved all entities into src/structure/entities instead
[x] whitelist/blacklist kernel system model
	[x] enforce hierarchy of roles
	[x] if an entity is private, reject association with blacklist
	[x] if an entity is public, reject association with whitelist
	[x] all operations require that the agent have equal or higher hierarchy
	[x] there can only be one root, and it is only granted on entity creation
		[x] create blacklist and whitelist root on entity creation
			[x] need a blacklist root to manage access control for public entities
			[x] we need the system to work when the privacy of a method is changed
[x] core system integrity checks should be independent of surface field validation
	[x] e.g. internal models such as relationships, whitelist, and blacklist should not depend on interface field validation to function
		[x] we need to ensure that only valid data gets saved to the database
		[x] is it reasonable to use middlewares for core system logic? maybe we should just inhouse it in the kernel because someone might change the abstract definition?
			[x] maybe the ideal design is for the kernel to be self-sufficient in every regard
	[x] keep the surface area of the internal core as small as possible
	[x] field validation should only be pushed to the surface for user level entities
[x] refactor src/structure to follow the same directory structure as src/abstract
	[x] make src/structure/entities
	[x] copy entities from root src/structure into src/structure/entities
		[x] delete ezuag and ytitne from src/structure
	[x] update only ezuag and ytitne to use the new src/structure/entities path
	[x] commit when all tests pass
	[x] update kernel initial skeleton by adding src/entities
	[x] update base from src to pull from src/structure/entities
	[x] update stages
	[x] commit when all paths have been updated
	[x] recompile
[ ] rename src/kernel/src/initial to src/kernel/src/skeleton
[x] move src/kernel/entities to src/kernel/src/entities
[x] move link and root functions used in schemas to kernel
[ ] refactor all kernel models
	[x] rename input to parameters
	[x] context, agent, parameters, entity, operation
		[x] centralize all authorization checks in two functions: authorization and authorization_set
	[ ] refactor access model to use system model authorization methods
[ ] use dataloader to batch data loading
	[x] use dataloader in database kernel model
	[x] use dataloader in system kernel model
	[x] use dataloader in relationship model
	[x] use dataloader in access models
	[x] hook up lru cache to all models
		[x] hook up lru cache to system model
		[x] hook up lru cache to database model
		[x] hook up lru cache to relationship model
		[x] hook up lru cache to access model
	[-] clear cache on update or delete
		[x] made a custom ttl based lru cache instead
			[-] use es6 map instead of an object as the store
				[x] seems faster to use an object because we are clearing it frequently
	[ ] granular cache clearing based on record (nice to have)
		[ ] e.g. if we update a record, it should only clear the cache for all read operations on the record
		[ ] will need to add a new data structure to the lru cache we implemented to keep track of operation association with records
			[ ] e.g. parse the parameters and construct a tree
	[ ] hash the key to have a fixed size for the key (nice to have)
[x] entity tests to test public access control
	[x] ytitne only tests private access control
[x] remove legacy relationship tests
[x] see if we can pass in a null agent_id into authorization and have it all work
	[x] verify that all authorization queries are valid with a null agent_id
		[x] add guards to ensure that agent_id is either a string or null
[ ] errors directory per realm
	[ ] realms can have their own custom errors, but only for the particular logic they are handling
		[ ] in all other cases, we should just bubble up the error from below
[ ] add a required attribute to fields in abstract entity definitions?
	[ ] we can use it to create two different attribute types
		[ ] one for creation, and another for querying and updating
[ ] use graphql enum types (https://graphql.org/graphql-js/type/#example-4) to lock down fields that act on a set of values
	[ ] entity_type, agent_type, realm, agent_role
	[ ] the problem is that using the enums is a pain because you need to know the name of the option
		[ ] we can introduce a naming convention, e.g. REALM__SYSTEM, AGENT_ROLE__ROOT, AGENT_ROLE__TRUNK, AGENT_ROLE__LEAF, etc
			[ ] but it is still awkward, and it feels like it would be easier to use if we just left it as a string field but added validation on it
	[x] add custom field validation for realm and agent_role for now
[x] basic authentication and session management so we have the concept of a user
	[x] account table (look at how passport and nextjs auth create their tables)
		[x] we designed our own
	[-] proxy graphiql via server
		[x] there is a section to add header information
	[x] use a higher level http server (express, fastify, koa, etc) ?
		[x] since we rolled our own auth, there is no reason to use a higher level http server
[x] design an authentication system
	[x] candidate one: wrapped jwts
	[-] candidate two: certificate chain
	[-] candidate three: one time passwords via communication channels (e.g. email or phone)
[ ] think about how to share data
	[ ] add a domain attribute to abstract entity definition so that entities can have a full address?
		[ ] e.g. {{ entity }}.entities.alexahn.com or {{ entity }}.gauze.alexahn.com
			[ ] nothing is actually hosted here, but we need a uniquely identifiable address for types of entities to form a language to exchange data
			[ ] or maybe a certificate is hosted here, that we can use to verify the signature of entity data
		[ ] maybe also change the name of all graphql type names to follow a similar convention so there is a one to one mapping between a type and a domain
			[ ] this way, if you know the domain, you will be able to look for the types, and if you know the type, you know the domain
				[ ] e.g. if company2 wants to use {{ entity }}.{{ company1 }}.com, then they also know the name of the graphql type so they know the structure of the data
			[ ] com.alexahn.Entity1, com.alexahn.Entity2, etc or Entity1.alexahn.com, Entity2.alexahn.com, etc
			[ ] graphql does not allow period in type names, so the best we can do is encode a period as three underscores (or something like this)
			[ ] maybe the domain is implicit, and only made relevant during schema stitching by programmatic prefixing of type names with the domain?
				[ ] but there will be ambiguity for types that are named the same, so it seems like everything should be namespaced
		[ ] have a type resolver query at root called "name_resolver" or something
			[ ] takes in a type name like "com.alexahn.Entity2" and returns the graphql type definition
		[ ] feels like interface types should be common types and concrete types should be namespaced?
		[ ] look into nested schemas, maybe we can avoid the naming problem if we can call schemas using schemas
			[ ] as an example, we can have a resolver that evaluates another schema (whose type definitions are bound within that schema)
				[ ] maybe we only need to associate a schema with a domain, as long as we have some domain router
					[ ] e.g. resolve("http://localhost:4000/graphql/Gauze_Mutation")
[x] create new tables and entities:
	[x] secret
	[x] session
	[x] proxy
	[x] agent_root
	[x] agent_account
	[x] agent_user
	[x] agent_person
	[x] agent_character
[x] login generalized across all agents according to assert, request, verify, login flow
	[x] src/environment/models/agent_root
	[x] src/environment/models/agent_account
	[x] src/environment/models/agent_user
	[x] src/environment/models/agent_person
	[x] src/environment/models/agent_character
[x] authentication flow
	[x] jwt for each realm
	[x] jwt payload is the store for agent information
	[x] signup
	[x] create anonymous session to handle authentication
		[x] assert person email
		[x] verify account password
	[x] enter session for non null agent
	[x] exit session
	[x] signout
[ ] bring back reality realm?
	[x] separate sessions for different realms
[x] change src_from_base to use the entities defined in the kernel for internal entities
[x] update kernel stages to use new entities
[ ] add field to abstract entity definition to exclude from graphql interface
	[ ] unless we specify the realm, we can't do this without also excluding from the database graphql interface
		[ ] then the linker has to take in a realm parameter
[ ] add field to abstract entity fields to exclude from graphql interface
	[ ] we can't do this without also excluding the field from the database graphql interface
[x] add agent_types field to method definitions for abstract entities (should be an array value of allowed agent types)
	[x] we can only do this if we change the interpretation of public to mean public inside an authenticated session
		[x] we probably have to do this because the root whitelist and blacklist are invalid without a valid session
			[-] not necessarily since a null agent id and agent type means that anyone can update or change the entity
				[-] to do this, we have to change agent_id and agent_type to be nullable in whitelist and blacklist, which seems like a pain
	[x] change system interface to reject non authenticated users
	[x] harden all agent type checks
[x] set up environment interface, controllers, and models
	[x] barebones piping to get the graphql mutations working
[x] fix class names generated from code (there is an underscore)
[x] put all auth functions into a central location so it is easy to use
	[x] should be a simple interface: authenticate(req) -> agent
[x] update delete methods to delete relationships in kernel database model
	[x] also delete whitelist and blacklists associated with the entity
[-] think about whether or not we want to make all associations to agent root instead of proxy root for sessions and secrets
	[-] it allows a simpler authentication architecture since we can change the jwt audience for the proxy session to be environment
	[-] but it causes more indirection in environment controllers because we need to use the agent root instead of proxy root
		[-] we could just add agent_root_id to the jwts
	[x] maybe not, because proxy has to be a system audience/realm authentication so that we can query the system interface
		[x] e.g. if we want to display the available proxies
[x] update system to use the agent parsed from the jwt
	[x] update all tests to use the new agent structure
[ ] refactor environment controllers to have a function that specifies the requirements to proceed (which is stored in session data)
	[ ] make a method on session to augment the session data so that it all goes through one place
	[ ] refactor all session data management to use something like "steps.person.assert.email.success", "steps.person.request.email.success", "steps.person.request.email.code", etc
		[ ] set login conditions based on step definitions (e.g. an array of success values for steps: ["steps.person.assert.email.success", "steps.person.verify.email.success", "steps.account.verify.password.success"])
[ ] use types defined in abstract realm for all environment graphql definitions
[ ] move guards outside of batch functions so that the errors are cleaner
	[x] system model
	[ ] relationship model
[ ] soft delete
	[ ] stringified javascript dates are utc, but the dates generated by new Date() use the system clock
[ ] refactor validate_entity_config to use dot path for error messages
[ ] server application clean up
	[ ] come up with a bare bones pattern to define url and routes
	[ ] refactor the server application
[ ] rate limiter
	[ ] by route, by ip, by account, by location, etc
[ ] change uuid to ulid
	[ ] validate id field to ensure ulid structure
	[ ] not sure we want to do this because the key encodes time information
		[ ] which will seep into the sharding design
		[ ] do we want to shard by chronological order?
		[ ] it has some interesting qualities, in that you would be able to provision servers ahead of time for a frame of time
			[ ] might make operations easier because the conceptual model is simple, basically a tape
[ ] whitelist / blacklist symmetry?
	[ ] should whitelist also only apply at leaf level? currently blacklist only applies at leaf level
[ ] build an admin management react app to dog food the interface
	[ ] have an admin method to track objects that have no relationships
	[ ] have an admin method to track objects that should be one to one but aren't
	[ ] add a command to create an agent and set it as an admin
	[ ] src/gauze.json
		[ ] track admin users by having a field in src/gauze.json called managers or admins that holds the agent root ids
			[ ] use the config from kernel system model to bypass authorization checks if the agent id is one of the managers
			[ ] the config will have to be split by environment
			[ ] this approach seems better than creating a table in sql because the set of managers is in source control
		[ ] track entities by using the project and gauze fields?
			[ ] the entities can just be parsed from $abstract, so maybe just create a method that returns a set of entities
[ ] think about some defensive programming strategies to handle the lack of one to one constraints and other similar structural ambiguities
	[ ] we might need to specify one to one relationships via structures
	[ ] constraint checking might be best done by creating a projection of counts for relationships because we need a data structure that is indexed on counts
		[ ] maybe a simple aggregation table that has from_type, to_type, from_id, count
			[ ] probably need to use something else that is commutative at the outer layer to avoid transactions locking too much?
				[ ] would be kind of a pain to lose transactional certainty and have to manage synchronization between two data sources
				[ ] just shard the table
			[ ] will probably need another aggregation table per item, that has the total count of relationships (to any entity) on the item
[ ] add attribute flag to designate builtin entities
[ ] type naming constraints
	[ ] cap table name to 255 characters
	[ ] cap graphql type name to 255 characters
	[ ] align name lengths with sql column limits for all types
[x] cached where in and cached where not in exposed to database graphql
	[x] value is a string key that is a key to a value in cache
	[x] hook up lru cache to system and database
[ ] file entity
	[ ] file handler entity
		[ ] manages an io entity that can read and write
	[ ] streaming interface for files
[ ] process entity
	[ ] input and output architecture
[ ] think about how to do field validation so that field errors can be abstracted
	[ ] currently we will just throw hand crafted errors, but we could probably have a structured approach
[ ] monolithic foundation
	[ ] source/version control system
	[ ] build system
	[ ] email
