[x] generalized mutation interface
[x] configure query and mutations to interact with a query builder (like knex)
[x] expose schema to http
[x] setup context with db connection
[ ] setup context with user authentication
[ ] build a react app to test out the architecture
[ ] dependency injection
	[ ] refactor everything later if we want the ability to thoroughly test every module
[x] might need to make our own rest handler because we need to know when queries/mutations are finished
[x] rename connection to database
[x] module naming and organizing conventions
	[x] barrel modules
[x] rename database/database.js to database/knex.js
[x] rename interface directories to interfaces
[ ] relationships modeling
	[x] create a table to track relationships
	[x] implement relationship traversal via queries
	[x] implement relationship creation and deletion via mutations
		[-] join update and join delete doesn't seem to work in sqlite3, maybe try postgresql
		[x] brute force this by re-using read method and using where in (works in sqlite and postgresql)
	[-] see if there a way to not forfeit foreign key constraints without having to create different tables for every type of relationship
		[x] look into constraints to manage one to one, one to many, and many to one relationships
			[x] we will have to handle this from the application level
	[ ] have an admin method to track objects that have no relationships
[x] logging
	[x] visually simple logging based on level, topic, and message
		[x] stack based prefixing based on variable inputs to write
	[-] look into using console.group and console.groupEnd as an alternative to manually managing a stack prefix
	[x] use the logger in all the modules
	[x] clean up console.log usage
[x] reorganize the structure module
	[x] entities should be the highest directory level
[-] look into deepcopy for graphql schema and type extension
	[x] just hard copy the graphql definitions
	[-] update graphql type names and descriptions to prefix or suffix with database, system, or user
		[x] too tedious, better to re-use the underlying unified type
[ ] type naming constraints
	[ ] cap table name to 255 characters
	[ ] cap graphql type name to 255 characters
[x] rename constants and variables in interfaces/mutations
[x] use constants defined in structures for table names for database models
[x] formalize query and mutations to look the same
	[x] split relationship type for query and mutation
	[x] re-expose query and mutation at entity level for nested queries and mutations
	[x] dynamically configure relationships, sub-queries, and sub-mutations by creating an abstraction
[x] shell / repl
[x] realms (database, system, user) should be written by using the exposed interface for the layer below
	[x] forces any circular dependencies to be made apparent
	[x] use structure as $structure
	[x] use kernel as $kernel
	[x] use database as $database
[x] update graphql type names to use two underscores as a separator
[x] change relationship column names (from to from_type, to to to_type)
[x] enable variables for graphql server
[x] investigate why orderBy is not working in knex with sqlite3
	[x] order_nulls breaks the query
	[x] remove order_nulls for now until we find a solution
[x] figure out a way to enable debugging of queries easily
	[x] toString method allows every query to be printed
	[x] put all sql queries into constants so they can be re-used
	[x] add new environment variables: GAUZE_DEBUG_SQL, GAUZE_DEBUG_GRAPHQL
[x] add primary key to database models and use them for the default order
	[x] add primary key to sql structures
[ ] refactor logger to make it functional (e.g. stop mutating arrays and have functions return fully transformed items)
	[x] remove the magic string by fully implementing the correct stack marking algorithm
		[x] turns out we don't need to change the code, we can just do a null checkl
[x] testing
	[x] set up example queries that line up with the seeded data
	[x] test create, read, update, delete
	[x] test relationships
	[x] test nested mutation and queries
[x] force sqlite file to be made at the root directory
[x] programmatically manage created_at, updated_at, deleted_at, id
	[x] add protected fields to sql structures
	[x] delete the fields prior to constructing a sql query
	[x] have the model handle them
	[x] add serializers to fields
[x] add graphql shell
	[x] add an execute function for database and system realms in the terminal
[x] refactor system controllers to use graphql queries/mutations against the database interface
	[x] might as well set it up now
	[x] copy existing system controllers and interface to database
	[x] will help with serializer logic as well since the serializers will all run at the database level
	[x] where in and where not in exposed to database graphql
		[x] where not in takes precedence over where in
	[x] where in and where not in exposed to system graphql
	[ ] implement error visibility (right now it's a little rough if something goes wrong)
[x] move server.js into command
[x] serialize / deserialize
	[x] call serialize and deserialize from controllers, but defined on models
[x] update constants in interface to use the subdirectory (e.g. add GRAPHQL)
[ ] convert operations from strings to source object for debugging purposes
	[ ] https://github.com/graphql/graphql-js/blob/main/src/language/source.ts
[x] update update and delete mutations to accept limit, offset, and order arguments 
[x] grep -r \~ .
	[x] vim shows ~ at the end of a file so sometimes it can blend in
[x] change serializers to be generators that accept a field name
[ ] basic authentication and session management so we have the concept of a user
	[ ] account table (look at how passport and nextjs auth create their tables)
	[ ] proxy graphiql via server
	[ ] use a higher level http server (express, fastify, koa, etc) ?
		[ ] url and routes
[x] move execute from terminal to kernel/shell
	[x] import execute from kernel and use in system models
	[x] refactor inputs to execute to make it pretty (e.g. context instead of contextValue, variables insead of variableValues)
	[ ] import execute from kernel and use in tests
[ ] add a _description attribute to every module so that the codebase can be explored via the repl
	[ ] always add the field at the end of every module definition so it shows up at the bottom in the repl
[ ] move object destructuring for database model inputs into the function itself (for debugging purposes when we want to log the entire input)
	[x] database models
[ ] add logging to system models
[x] fix structure names in graphql.js and sql.js files
	[x] GRAPHQL_DATABASE_RELATIONSHIP_ATTRIBUTES_FIELDS_ARRAY_STRUCTURE shoudl be ATTRIBUTES_FIELDS_ARRAY_GRAPHQL_DATABASE_RELATIONSHIP_STRUCTURE
		[x] maybe introduce a double underscore convention to seperate the namespace from the item?
			[x] ATTRIBUTES_FIELDS_ARRAY__GRAPHQL__DATABASE__RELATIONSHIP__STRUCTURE ?
				[x] does seem more clear
	[x] sql.js
	[x] graphql.js
	[x] database/interfaces/operations
	[x] schemas
	[x] queries and mutations
	[x] kernel/shell
	[x] kernel/logger
	[x] kernel/cache
[x] rename columns in relationship table
	[x] example: _id to gauze__relationship__id
	[x] example: _from_id to gauze__relationship__from_id
	[x] we want to avoid naming conflicts on joins with builtin tables
	[x] use as precedent for new builtin tables (e.g. whitelist and blacklist tables)
[x] format graphql to make it consisten
	[x] time to switch to prettier? (https://prettier.io/docs/en/index.html)
[ ] permissions and authorization
	[-] row based security (postgresql)?
		[-] seems like it is technically complex because we'd need to authenticate every user to postgresql
		[-] the application code isn't complex, but the database tuning and management would be
		[-] the example policies i could find also don't seem to be that flexible, and it might be hard to set them up without duplicating relationship data across entities
	[ ] maybe some kind of bit field if we want to be efficient?
	[x] simple white and black list permissions
		[x] subcategorized by realm
	[x] whitelist and blacklist tables
	[x] structure information for default mode for methods (e.g. private or public)
	[x] blacklist and whitelist structures
	[x] blacklist and whitelist database models, controllers, and interface
[ ] cached where in and cached where not in exposed to database graphql
	[ ] value is a string key that is a key to a value in cache
	[ ] hook up lru cache to system and database
[x] accept a query parameter to simulate user id
	[x] allows us to work on permission/authorization layer without having a user table
	[x] agent_id is exposed for all queries and mutations to simulate an agent
[x] add parent argument to database graphql queries and mutations
	[x] it should have a structure like:  { _metadata: { id, type } }
	[x] we need this to pass in the source (e.g. parent) from the system to honor relationships
[ ] file entity
	[ ] file handler entity
		[ ] manages an io entity that can read and write
	[ ] streaming interface for files
[ ] process entity
	[ ] input and output architecture
[x] think about realm organization
	[x] might make more sense if system had an account, and application had a user
	[x] might make more sense if reality had a person, and story had a character
	[x] system can host applications and reality can host stories?
	[x] introduce concept of application
		[x] application realm interacts with user
	[x] system realm now interacts with account
	[x] add environment realm
	[x] for now system will represent the initial application (we can rename it later)
[x] update tables to use uuids so we can one shot bindings
	[x] 00000000-0000-0000-0000-000000000001 format for seed data
[x] create protected fields and update protected fields?
	[x] do we need to enforce not being able to change some fields after they are set?
		[x] split all protected fields to be implemented as pre serializer middleware
[x] proper names for entities and gauze files generated from kernel
[ ] turn kernel into a proper stack
	[x] kernel/controllers/class.js
	[x] kernel/models/class.js
	[ ] kernel/interfaces
		[ ] manage cache, logging, shell, infrastructure, etc
[x] start thinking about kernel/src or kernel/source
	[x] bootstrap new project by using commands that use the source code
		[x] should have commands to create new entities
			[-] base everything off structures
				[x] base everything off abstract atoms
			[x] look into programmatically generating graphql and sql structures from an abstract structure
				[ ] look into doing ast parsing and some table management data structures to programmatically generate migration files
	[x] create abstract structures
	[x] move entity1 and entity2 into kernel/src/migrations to make it easier for development
		[ ] remove later once we can generate entities
		[ ] move these migrations to structure?
	[x] base structure in kernel
	[x] base database model, controller, and interface
	[x] base system model, controller, and interface
	[x] fuse base_entity and base_gauze as base
	[ ] add gauze.json as a config file for the gauze cli (which will keep track of gauze base models and developer entities)
	[x] yargs cli for project
		[x] run server to use kernel server application
		[x] run terminal to use kernel terminal application
		[x] create, read, update, and delete to use kernel manager application
		[x] command directory
			[x] yargs?
			[x] terminal
			[x] server
			[x] create project
			[ ] read project
			[ ] update project
			[x] create entity
			[x] read entity (see todo below)
			[x] update entity
			[x] delete entity
		[ ] align environment variables with cli commands
	[-] centralize all zsh/bash scripts under the root bin directory?
		[-] or maybe have src/kernel/bin?
			[-] better to have a root level directory that is the interface with the outer operating system
		[x] maybe src/kernel/bin is better because the copied code will be self-contained
			[x] migrate root bin to kernel/bin
	[x] gauze cli (from node_modules), gauze-project cli (from bootstrapped project)
		[x] implemented as a subcommand for the gauze cli to proxy into the project cli
	[x] reorder export order in module files so that internal files are first
	[x] move base classes to the kernel
[ ] have read command manually construct a list of files and directories and intersect with the results from find
	[ ] kind of problematic when we just use find because an entity might contain another entity's name inside it
		[ ] e.g. hello_entity and hello_entity_world
[x] refactor server application to use kernel graphql shell execute
[x] update schema files to use $structure instead of directly importing
[-] group protected fields by method for sql structures
	[x] protected fields are now handled via pre_serializer middlewares
[ ] add attribute flag to designate builtin entities
[x] refactor schema to use interface entities
	[x] add new files to base kernel
[x] refactor all exports to use the same naming convention (need two underscores instead of one in a lot of places)
[ ] use es6 map for lru cache (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
[x] copy the date graphql scalar so we have one less dependency
[x] sub categorize internal gauze commands and user commands
	[x] add example user command (so they can write their own webserver for example)
[ ] polish commands and manager application
[x] set up migrations for ezuag and ytitne
[x] set up seed data for ezuag and ytitne
[x] merge system models into one (there is no reason to have multiple)
[ ] naming convention refactor (update according to all rules)
	[x] double underscore for module namespacing hierarchy
	[ ] only use upper snake case for global constants and module exports (convert in function const to lower snake case)
[x] rename all kernel model methods to be underscore prefixed
	[x] refactor database models so that they have create, read, update, delete methods that proxy to the kernel method
		[x] allows for people to extend the models however they want, while preserving core internal logic
[x] update create operations to also create a whitelist entry
[x] isolated tests
	[x] make ytitne self-relational
	[x] don't depend on seed data for tests
		[x] will still depend on tables existing because we aren't programmatically generating migration files
	[x] combinatorially try most system states
		[x] need a consise way to write these tests, the current way is too heavy
			[x] write a way to define tests by treating the interface(s) as functions
			[x] make a steps loader and steps runner
		[x] tests for access control
		[x] creating relationships (should only be possible to create relationships for things the agent can access)
[x] use import.meta.filename instead of parsing import.meta.url
[x] add mandatory input guards in controllers (or into the type definition?)
	[x] as an example, attributes can currently be null right now, which causes an error
	[x] tried to do it through graphql type definitions but it is a pain in the ass because it treats the new type as a different type
		[x] the error message that graphql returns isn't exceptionally useful, so we can just throw our own error
[x] prevent update/delete from working with an empty where query? there is no reason to update everything a user has access to
	[x] added guards to database kernel model to check that where is provided
	[ ] think about how to make this prettier later
[x] logging strategy so we can see the entire access control pipeline from beginning to end
	[x] just prefix the message with something like 'access'
[x] move sql table name to abstract entities
[x] move graphql meta type to abstract entities (the meta type is not a name that is encoded within the schema, but a framework identifier)
[x] refactor structure/resolvers to use abstract entities so we can reduce the surface area of the staging layers
	[x] delete resolver staging files
[ ] think about how to do field validation so that field errors can be abstracted
	[ ] currently we will just throw hand crafted errors, but we could probably have a structured approach
[ ] refactor kernel models to have elegant function signatures
	[ ] should probably group things together to have better conceptual clarity instead of abusing positional arguments
[ ] prevent particular types of data from being created, such as relationships on relationships
	[ ] gauze internal models should be siloed as much as possible
[x] update system model create method to do policy checking just like other system model methods
	[x] null entity_id in whitelist means the whitelist applies to the entire collection for the particular method
[ ] optimizations for high performance
	[ ] have a look up data structure/table that maps the table name in the database to a readable name
		[ ] table names are limited to 4 characters in the database
	[ ] have a look up data structure/table that maps the method name in field values to a readable value
		[ ] methods are limited to 4 characters in the database
	[ ] have a look up data structure/table that maps the realm name in field values to a readable value
		[ ] realms are limited to 4 characters in the database
[x] rework workspace entities
	[x] rename entity1 to entity
		[x] remove relationship from entity to entity2
		[x] rework seed data
	[x] rename entity2 to gauze (internal)
		[x] remove relationship from gauze to entity1
		[x] rework seed data
	[x] reconfigure stages
		[x] will need to have a truncated stage for the last two stages so that teardown doesn't crash
		[x] after successful setup copy the new stages to the last two stages
[x] move all existence checks to the edge (e.g. attributes, where, where_in, etc)
	[x] to interfaces
[-] change _access_execute in system model to not throw errors
[-] make a database directory per steps directory that has initialization for the database
	[-] run the steps in the database directory against the database schema
	[-] we should be able to one shot initialization for every test case using the database interface
	[-] currently, we are relying on the seed data for whitelist to enable creating models for two fixed agent ids
	[x] or we can set up independent seed sources, so that test data has its own reliable seed structure
		[x] tests now use src/database/seeds/test
[x] prevent relationships from being made if the from and to are not connected
	[x] use structure definition
	[x] rename DATABASE_RELATIONSHIP_STRUCTURE to proper naming convention
		[x] don't import DATABASE_RELATIONSHIP_STRUCTURE directly from schemas
	[-] rename structure/relationships to structure/connections
		[x] moved all entities into src/structure/entities instead
[x] whitelist/blacklist kernel system model
	[x] enforce hierarchy of roles
	[x] if an entity is private, reject association with blacklist
	[x] if an entity is public, reject association with whitelist
	[x] all operations require that the agent have equal or higher hierarchy
	[x] there can only be one root, and it is only granted on entity creation
		[x] create blacklist and whitelist root on entity creation
			[x] need a blacklist root to manage access control for public entities
			[x] we need the system to work when the privacy of a method is changed
[x] core system integrity checks should be independent of surface field validation
	[x] e.g. internal models such as relationships, whitelist, and blacklist should not depend on interface field validation to function
		[x] we need to ensure that only valid data gets saved to the database
		[x] is it reasonable to use middlewares for core system logic? maybe we should just inhouse it in the kernel because someone might change the abstract definition?
			[x] maybe the ideal design is for the kernel to be self-sufficient in every regard
	[x] keep the surface area of the internal core as small as possible
	[x] field validation should only be pushed to the surface for user level entities
[x] refactor src/structure to follow the same directory structure as src/abstract
	[x] make src/structure/entities
	[x] copy entities from root src/structure into src/structure/entities
		[x] delete ezuag and ytitne from src/structure
	[x] update only ezuag and ytitne to use the new src/structure/entities path
	[x] commit when all tests pass
	[x] update kernel initial skeleton by adding src/entities
	[x] update base from src to pull from src/structure/entities
	[x] update stages
	[x] commit when all paths have been updated
	[x] recompile
[ ] rename src/kernel/src/initial to src/kernel/src/skeleton
[x] move src/kernel/entities to src/kernel/src/entities
[x] move link and root functions used in schemas to kernel
[ ] refactor all kernel models
	[x] rename input to parameters
	[x] context, agent, parameters, entity, operation
		[x] centralize all authorization checks in two functions: authorization and authorization_set
	[ ] refactor access model to use system model authorization methods
[ ] entity tests to test public access control
	[ ] ytitne only tests private access control
[ ] use dataloader to batch data loading
	[x] use dataloader in database kernel model
	[x] use dataloader in system kernel model
	[x] use dataloader in relationship model
	[x] use dataloader in access models
	[x] hook up lru cache to all models
		[x] hook up lru cache to system model
		[x] hook up lru cache to database model
		[x] hook up lru cache to relationship model
		[x] hook up lru cache to access model
	[-] clear cache on update or delete
		[x] made a custom ttl based lru cache instead
			[ ] use es6 map instead of an object as the store
	[ ] granular cache clearing based on record (nice to have)
		[ ] e.g. if we update a record, it should only clear the cache for all read operations on the record
		[ ] will need to add a new data structure to the lru cache we implemented to keep track of operation association with records
			[ ] e.g. parse the parameters and construct a tree
	[ ] hash the key to have a fixed size for the key (nice to have)
[ ] soft delete
[ ] validate id field to ensure uuid structure
[x] see if we can pass in a null agent_id into authorization and have it all work
	[x] verify that all authorization queries are valid with a null agent_id
		[x] add guards to ensure that agent_id is either a string or null
[ ] whitelist / blacklist symmetry?
	[ ] should whitelist also only apply at leaf level? currently blacklist only applies at leaf level
[ ] errors directory per realm
	[ ] realms can have their own custom errors, but only for the particular logic they are handling
		[ ] in all other cases, we should just bubble up the error from below
[ ] add a required attribute to fields in abstract entity definitions?
	[ ] we can use it to create two different attribute types
		[ ] one for creation, and another for querying and updating
[ ] use graphql enum types (https://graphql.org/graphql-js/type/#example-4) to lock down fields that act on a set of values
	[ ] entity_type, agent_type, realm, agent_role
	[ ] the problem is that using the enums is a pain because you need to know the name of the option
		[ ] we can introduce a naming convention, e.g. REALM__SYSTEM, AGENT_ROLE__ROOT, AGENT_ROLE__TRUNK, AGENT_ROLE__LEAF, etc
			[ ] but it is still awkward, and it feels like it would be easier to use if we just left it as a string field but added validation on it
	[x] add custom field validation for realm and agent_role for now
