[x] generalized mutation interface
[x] configure query and mutations to interact with a query builder (like knex)
[x] expose schema to http
[x] setup context with db connection
[ ] setup context with user authentication
[ ] build a react app to test out the architecture
[ ] dependency injection
	[ ] refactor everything later if we want the ability to thoroughly test every module
[x] might need to make our own rest handler because we need to know when queries/mutations are finished
[x] rename connection to database
[x] module naming and organizing conventions
	[x] barrel modules
[x] rename database/database.js to database/knex.js
[x] rename interface directories to interfaces
[ ] relationships modeling
	[x] create a table to track relationships
		[ ] look into constraints to manage one to one, one to many, and many to one relationships
	[x] implement relationship traversal via queries
	[-] implement relationship creation and deletion via mutations
		[ ] doesn't seem to work in sqlite3, maybe try postgresql
		[ ] brute force this by re-using read method and using where in
	[ ] see if there a way to not forfeit foreign key constraints without having to create different tables for every type of relationship
[x] logging
	[x] visually simple logging based on level, topic, and message
		[x] stack based prefixing based on variable inputs to write
	[ ] look into using console.group and console.groupEnd as an alternative to manually managing a stack prefix
	[x] use the logger in all the modules
	[x] clean up console.log usage
[x] reorganize the structure module
	[x] entities should be the highest directory level
[ ] look into programmatically generating graphql and sql structures from an abstract structure
[ ] look into deepcopy for graphql schema and type extension
	[ ] update graphql type names and descriptions to prefix or suffix with database, system, or user
[ ] type naming constraints
	[ ] cap table name to 255 characters
	[ ] cap graphql type name to 255 characters
[x] rename constants and variables in interfaces/mutations
[x] use constants defined in structures for table names for database models
[x] formalize query and mutations to look the same
	[x] split relationship type for query and mutation
	[x] re-expose query and mutation at entity level for nested queries and mutations
	[x] dynamically configure relationships, sub-queries, and sub-mutations by creating an abstraction
[x] shell / repl
[ ] command directory
	[ ] yargs?
	[x] terminal
	[ ] server
	[ ] manage?
[ ] permissions and authorization
	[-] row based security (postgresql)?
		[-] seems like it is technically complex because we'd need to authenticate every user to postgresql
		[-] the application code isn't complex, but the database tuning and management would be
		[-] the example policies i could find also don't seem to be that flexible, and it might be hard to set them up without duplicating relationship data across entities
	[ ] maybe some kind of bit field if we want to be efficient?
	[ ] simple white and black list permissions
		[ ] system permissions
		[ ] user permissions
[ ] url and routes
[ ] should realms (database, system, user) be written by using the exposed interface for the layer below?
	[ ] forces any circular dependencies to be made apparent, so maybe a good idea
[x] use kernel as $kernel
[ ] use database as $database?
[ ] bootstrap new project by using commands
	[ ] should have commands to create new entities
[x] update graphql type names to use two underscores as a separator
[x] change relationship column names (from to from_type, to to to_type)
[x] enable variables for graphql server
[ ] use a higher level http server (express, fastify, koa, etc)
