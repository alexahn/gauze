[x] generalized mutation interface
[x] configure query and mutations to interact with a query builder (like knex)
[x] expose schema to http
[x] setup context with db connection
[x] setup context with user authentication
[ ] dependency injection
	[ ] refactor everything later if we want the ability to thoroughly test every module
[x] might need to make our own rest handler because we need to know when queries/mutations are finished
[x] rename connection to database
[x] module naming and organizing conventions
	[x] barrel modules
[x] rename database/database.js to database/knex.js
[x] rename interface directories to interfaces
[x] relationships modeling
	[x] create a table to track relationships
	[x] implement relationship traversal via queries
	[x] implement relationship creation and deletion via mutations
		[-] join update and join delete doesn't seem to work in sqlite3, maybe try postgresql
		[x] brute force this by re-using read method and using where in (works in sqlite and postgresql)
	[-] see if there a way to not forfeit foreign key constraints without having to create different tables for every type of relationship
		[x] look into constraints to manage one to one, one to many, and many to one relationships
			[x] we will have to handle this from the application level
[x] logging
	[x] visually simple logging based on level, topic, and message
		[x] stack based prefixing based on variable inputs to write
	[-] look into using console.group and console.groupEnd as an alternative to manually managing a stack prefix
	[x] use the logger in all the modules
	[x] clean up console.log usage
[x] reorganize the structure module
	[x] entities should be the highest directory level
[-] look into deepcopy for graphql schema and type extension
	[x] just hard copy the graphql definitions
	[-] update graphql type names and descriptions to prefix or suffix with database, system, or user
		[x] too tedious, better to re-use the underlying unified type
[x] rename constants and variables in interfaces/mutations
[x] use constants defined in structures for table names for database models
[x] formalize query and mutations to look the same
	[x] split relationship type for query and mutation
	[x] re-expose query and mutation at entity level for nested queries and mutations
	[x] dynamically configure relationships, sub-queries, and sub-mutations by creating an abstraction
[x] shell / repl
[x] realms (database, system, user) should be written by using the exposed interface for the layer below
	[x] forces any circular dependencies to be made apparent
	[x] use structure as $structure
	[x] use kernel as $kernel
	[x] use database as $database
[x] update graphql type names to use two underscores as a separator
[x] change relationship column names (from to from_type, to to to_type)
[x] enable variables for graphql server
[x] investigate why orderBy is not working in knex with sqlite3
	[x] order_nulls breaks the query
	[x] remove order_nulls for now until we find a solution
[x] figure out a way to enable debugging of queries easily
	[x] toString method allows every query to be printed
	[x] put all sql queries into constants so they can be re-used
	[x] add new environment variables: GAUZE_DEBUG_SQL, GAUZE_DEBUG_GRAPHQL
[x] add primary key to database models and use them for the default order
	[x] add primary key to sql structures
[-] refactor logger to make it functional (e.g. stop mutating arrays and have functions return fully transformed items)
	[x] remove the magic string by fully implementing the correct stack marking algorithm
		[x] turns out we don't need to change the code, we can just do a null checkl
[x] testing
	[x] set up example queries that line up with the seeded data
	[x] test create, read, update, delete
	[x] test relationships
	[x] test nested mutation and queries
[x] force sqlite file to be made at the root directory
[x] programmatically manage created_at, updated_at, deleted_at, id
	[x] add protected fields to sql structures
	[x] delete the fields prior to constructing a sql query
	[x] have the model handle them
	[x] add serializers to fields
[x] add graphql shell
	[x] add an execute function for database and system realms in the terminal
[x] refactor system controllers to use graphql queries/mutations against the database interface
	[x] might as well set it up now
	[x] copy existing system controllers and interface to database
	[x] will help with serializer logic as well since the serializers will all run at the database level
	[x] where in and where not in exposed to database graphql
		[x] where not in takes precedence over where in
	[x] where in and where not in exposed to system graphql
	[x] implement error visibility (right now it's a little rough if something goes wrong)
[x] move server.js into command
[x] serialize / deserialize
	[x] call serialize and deserialize from controllers, but defined on models
[x] update constants in interface to use the subdirectory (e.g. add GRAPHQL)
[ ] convert operations from strings to source object for debugging purposes
	[ ] https://github.com/graphql/graphql-js/blob/main/src/language/source.ts
[x] update update and delete mutations to accept limit, offset, and order arguments 
[x] grep -r \~ .
	[x] vim shows ~ at the end of a file so sometimes it can blend in
[x] change serializers to be generators that accept a field name
[x] move execute from terminal to kernel/shell
	[x] import execute from kernel and use in system models
	[x] refactor inputs to execute to make it pretty (e.g. context instead of contextValue, variables insead of variableValues)
	[x] import execute from kernel and use in tests
[x] move object destructuring for database model inputs into the function itself (for debugging purposes when we want to log the entire input)
	[x] database models
[x] add logging to system models
[x] fix structure names in graphql.js and sql.js files
	[x] GRAPHQL_DATABASE_RELATIONSHIP_ATTRIBUTES_FIELDS_ARRAY_STRUCTURE shoudl be ATTRIBUTES_FIELDS_ARRAY_GRAPHQL_DATABASE_RELATIONSHIP_STRUCTURE
		[x] maybe introduce a double underscore convention to seperate the namespace from the item?
			[x] ATTRIBUTES_FIELDS_ARRAY__GRAPHQL__DATABASE__RELATIONSHIP__STRUCTURE ?
				[x] does seem more clear
	[x] sql.js
	[x] graphql.js
	[x] database/interfaces/operations
	[x] schemas
	[x] queries and mutations
	[x] kernel/shell
	[x] kernel/logger
	[x] kernel/cache
[x] rename columns in relationship table
	[x] example: _id to gauze__relationship__id
	[x] example: _from_id to gauze__relationship__from_id
	[x] we want to avoid naming conflicts on joins with builtin tables
	[x] use as precedent for new builtin tables (e.g. whitelist and blacklist tables)
[x] format graphql to make it consisten
	[x] time to switch to prettier? (https://prettier.io/docs/en/index.html)
[x] permissions and authorization
	[-] row based security (postgresql)?
		[-] seems like it is technically complex because we'd need to authenticate every user to postgresql
		[-] the application code isn't complex, but the database tuning and management would be
		[-] the example policies i could find also don't seem to be that flexible, and it might be hard to set them up without duplicating relationship data across entities
	[-] maybe some kind of bit field if we want to be efficient?
		[x] just cache the access control rows in memory if necessary
	[x] simple white and black list permissions
		[x] subcategorized by realm
	[x] whitelist and blacklist tables
	[x] structure information for default mode for methods (e.g. private or public)
	[x] blacklist and whitelist structures
	[x] blacklist and whitelist database models, controllers, and interface
[x] accept a query parameter to simulate user id
	[x] allows us to work on permission/authorization layer without having a user table
	[x] agent_id is exposed for all queries and mutations to simulate an agent
[x] add parent argument to database graphql queries and mutations
	[x] it should have a structure like:  { _metadata: { id, type } }
	[x] we need this to pass in the source (e.g. parent) from the system to honor relationships
[x] think about realm organization
	[x] might make more sense if system had an account, and application had a user
	[x] might make more sense if reality had a person, and story had a character
	[x] system can host applications and reality can host stories?
	[x] introduce concept of application
		[x] application realm interacts with user
	[x] system realm now interacts with account
	[x] add environment realm
	[x] for now system will represent the initial application (we can rename it later)
[x] update tables to use uuids so we can one shot bindings
	[x] 00000000-0000-0000-0000-000000000001 format for seed data
[x] create protected fields and update protected fields?
	[x] do we need to enforce not being able to change some fields after they are set?
		[x] split all protected fields to be implemented as pre serializer middleware
[x] proper names for entities and gauze files generated from kernel
[x] start thinking about kernel/src or kernel/source
	[x] bootstrap new project by using commands that use the source code
		[x] should have commands to create new entities
			[-] base everything off structures
				[x] base everything off abstract atoms
			[x] look into programmatically generating graphql and sql structures from an abstract structure
	[x] create abstract structures
	[x] move entity1 and entity2 into kernel/src/migrations to make it easier for development
		[x] remove later once we can generate entities
		[-] move these migrations to structure?
	[x] base structure in kernel
	[x] base database model, controller, and interface
	[x] base system model, controller, and interface
	[x] fuse base_entity and base_gauze as base
	[x] yargs cli for project
		[x] run server to use kernel server application
		[x] run terminal to use kernel terminal application
		[x] create, read, update, and delete to use kernel manager application
		[x] command directory
			[x] yargs?
			[x] terminal
			[x] server
			[x] create project
			[x] create entity
			[x] read entity (see todo below)
			[x] update entity
			[x] delete entity
	[-] centralize all zsh/bash scripts under the root bin directory?
		[-] or maybe have src/kernel/bin?
			[-] better to have a root level directory that is the interface with the outer operating system
		[x] maybe src/kernel/bin is better because the copied code will be self-contained
			[x] migrate root bin to kernel/bin
	[x] gauze cli (from node_modules), gauze-project cli (from bootstrapped project)
		[x] implemented as a subcommand for the gauze cli to proxy into the project cli
	[x] reorder export order in module files so that internal files are first
	[x] move base classes to the kernel
[x] refactor server application to use kernel graphql shell execute
[x] update schema files to use $structure instead of directly importing
[-] group protected fields by method for sql structures
	[x] protected fields are now handled via pre_serializer middlewares
[x] refactor schema to use interface entities
	[x] add new files to base kernel
[x] refactor all exports to use the same naming convention (need two underscores instead of one in a lot of places)
[-] use es6 map for lru cache (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
	[x] refactored the lru cache but the performance seems worse
[x] copy the date graphql scalar so we have one less dependency
[x] sub categorize internal gauze commands and user commands
	[x] add example user command (so they can write their own webserver for example)
[x] set up migrations for ezuag and ytitne
[x] set up seed data for ezuag and ytitne
[x] merge system models into one (there is no reason to have multiple)
[x] rename all kernel model methods to be underscore prefixed
	[x] refactor database models so that they have create, read, update, delete methods that proxy to the kernel method
		[x] allows for people to extend the models however they want, while preserving core internal logic
[x] update create operations to also create a whitelist entry
[x] isolated tests
	[x] make ytitne self-relational
	[x] don't depend on seed data for tests
		[x] will still depend on tables existing because we aren't programmatically generating migration files
	[x] combinatorially try most system states
		[x] need a consise way to write these tests, the current way is too heavy
			[x] write a way to define tests by treating the interface(s) as functions
			[x] make a steps loader and steps runner
		[x] tests for access control
		[x] creating relationships (should only be possible to create relationships for things the agent can access)
[x] use import.meta.filename instead of parsing import.meta.url
[x] add mandatory input guards in controllers (or into the type definition?)
	[x] as an example, attributes can currently be null right now, which causes an error
	[x] tried to do it through graphql type definitions but it is a pain in the ass because it treats the new type as a different type
		[x] the error message that graphql returns isn't exceptionally useful, so we can just throw our own error
[x] prevent update/delete from working with an empty where query? there is no reason to update everything a user has access to
	[x] added guards to database kernel model to check that where is provided
	[ ] think about how to make this prettier later
[x] logging strategy so we can see the entire access control pipeline from beginning to end
	[x] just prefix the message with something like 'access'
[x] move sql table name to abstract entities
[x] move graphql meta type to abstract entities (the meta type is not a name that is encoded within the schema, but a framework identifier)
[x] refactor structure/resolvers to use abstract entities so we can reduce the surface area of the staging layers
	[x] delete resolver staging files
[x] prevent particular types of data from being created, such as relationships on relationships
	[x] gauze internal models should be siloed as much as possible
	[x] perform checks for entity_type, and agent_type for internal models
[x] update system model create method to do policy checking just like other system model methods
	[x] null entity_id in whitelist means the whitelist applies to the entire collection for the particular method
[ ] optimizations for high performance
	[ ] have a look up data structure/table that maps the table name in the database to a readable name
		[ ] table names are limited to 4 characters in the database
	[ ] have a look up data structure/table that maps the method name in field values to a readable value
		[ ] methods are limited to 4 characters in the database
	[ ] have a look up data structure/table that maps the realm name in field values to a readable value
		[ ] realms are limited to 4 characters in the database
[x] rework workspace entities
	[x] rename entity1 to entity
		[x] remove relationship from entity to entity2
		[x] rework seed data
	[x] rename entity2 to gauze (internal)
		[x] remove relationship from gauze to entity1
		[x] rework seed data
	[x] reconfigure stages
		[x] will need to have a truncated stage for the last two stages so that teardown doesn't crash
		[x] after successful setup copy the new stages to the last two stages
[x] move all existence checks to the edge (e.g. attributes, where, where_in, etc)
	[x] to interfaces
[-] change _access_execute in system model to not throw errors
[-] make a database directory per steps directory that has initialization for the database
	[-] run the steps in the database directory against the database schema
	[-] we should be able to one shot initialization for every test case using the database interface
	[-] currently, we are relying on the seed data for whitelist to enable creating models for two fixed agent ids
	[x] or we can set up independent seed sources, so that test data has its own reliable seed structure
		[x] tests now use src/database/seeds/test
[x] prevent relationships from being made if the from and to are not connected
	[x] use structure definition
	[x] rename DATABASE_RELATIONSHIP_STRUCTURE to proper naming convention
		[x] don't import DATABASE_RELATIONSHIP_STRUCTURE directly from schemas
	[-] rename structure/relationships to structure/connections
		[x] moved all entities into src/structure/entities instead
[x] whitelist/blacklist kernel system model
	[x] enforce hierarchy of roles
	[x] if an entity is private, reject association with blacklist
	[x] if an entity is public, reject association with whitelist
	[x] all operations require that the agent have equal or higher hierarchy
	[x] there can only be one root, and it is only granted on entity creation
		[x] create blacklist and whitelist root on entity creation
			[x] need a blacklist root to manage access control for public entities
			[x] we need the system to work when the privacy of a method is changed
[x] core system integrity checks should be independent of surface field validation
	[x] e.g. internal models such as relationships, whitelist, and blacklist should not depend on interface field validation to function
		[x] we need to ensure that only valid data gets saved to the database
		[x] is it reasonable to use middlewares for core system logic? maybe we should just inhouse it in the kernel because someone might change the abstract definition?
			[x] maybe the ideal design is for the kernel to be self-sufficient in every regard
	[x] keep the surface area of the internal core as small as possible
	[x] field validation should only be pushed to the surface for user level entities
[x] refactor src/structure to follow the same directory structure as src/abstract
	[x] make src/structure/entities
	[x] copy entities from root src/structure into src/structure/entities
		[x] delete ezuag and ytitne from src/structure
	[x] update only ezuag and ytitne to use the new src/structure/entities path
	[x] commit when all tests pass
	[x] update kernel initial skeleton by adding src/entities
	[x] update base from src to pull from src/structure/entities
	[x] update stages
	[x] commit when all paths have been updated
	[x] recompile
[x] move src/kernel/entities to src/kernel/src/entities
[x] move link and root functions used in schemas to kernel
[ ] refactor all kernel models
	[x] rename input to parameters
	[x] context, agent, parameters, entity, operation
		[x] centralize all authorization checks in two functions: authorization and authorization_set
	[ ] refactor access model to use system model authorization methods
[x] use dataloader to batch data loading
	[x] use dataloader in database kernel model
	[x] use dataloader in system kernel model
	[x] use dataloader in relationship model
	[x] use dataloader in access models
	[x] hook up lru cache to all models
		[x] hook up lru cache to system model
		[x] hook up lru cache to database model
		[x] hook up lru cache to relationship model
		[x] hook up lru cache to access model
	[-] clear cache on update or delete
		[x] made a custom ttl based lru cache instead
			[-] use es6 map instead of an object as the store
				[x] seems faster to use an object because we are clearing it frequently
	[-] hash the key to have a fixed size for the key (nice to have)
[x] entity tests to test public access control
	[x] ytitne only tests private access control
[x] remove legacy relationship tests
[x] see if we can pass in a null agent_id into authorization and have it all work
	[x] verify that all authorization queries are valid with a null agent_id
		[x] add guards to ensure that agent_id is either a string or null
	[x] add custom field validation for realm and agent_role for now
[x] basic authentication and session management so we have the concept of a user
	[x] account table (look at how passport and nextjs auth create their tables)
		[x] we designed our own
	[-] proxy graphiql via server
		[x] there is a section to add header information
	[x] use a higher level http server (express, fastify, koa, etc) ?
		[x] since we rolled our own auth, there is no reason to use a higher level http server
[x] design an authentication system
	[x] candidate one: wrapped jwts
	[-] candidate two: certificate chain
	[-] candidate three: one time passwords via communication channels (e.g. email or phone)
[ ] think about how to share data
	[ ] add a domain attribute to abstract entity definition so that entities can have a full address?
		[ ] e.g. {{ entity }}.entities.alexahn.com or {{ entity }}.gauze.alexahn.com
			[ ] nothing is actually hosted here, but we need a uniquely identifiable address for types of entities to form a language to exchange data
			[ ] or maybe a certificate is hosted here, that we can use to verify the signature of entity data
		[ ] maybe also change the name of all graphql type names to follow a similar convention so there is a one to one mapping between a type and a domain
			[ ] this way, if you know the domain, you will be able to look for the types, and if you know the type, you know the domain
				[ ] e.g. if company2 wants to use {{ entity }}.{{ company1 }}.com, then they also know the name of the graphql type so they know the structure of the data
			[ ] com.alexahn.Entity1, com.alexahn.Entity2, etc or Entity1.alexahn.com, Entity2.alexahn.com, etc
			[ ] graphql does not allow period in type names, so the best we can do is encode a period as three underscores (or something like this)
			[ ] maybe the domain is implicit, and only made relevant during schema stitching by programmatic prefixing of type names with the domain?
				[ ] but there will be ambiguity for types that are named the same, so it seems like everything should be namespaced
		[ ] have a type resolver query at root called "name_resolver" or something
			[ ] takes in a type name like "com.alexahn.Entity2" and returns the graphql type definition
		[ ] feels like interface types should be common types and concrete types should be namespaced?
		[ ] look into nested schemas, maybe we can avoid the naming problem if we can call schemas using schemas
			[ ] as an example, we can have a resolver that evaluates another schema (whose type definitions are bound within that schema)
				[ ] maybe we only need to associate a schema with a domain, as long as we have some domain router
					[ ] e.g. resolve("http://localhost:4000/graphql/Gauze_Mutation") if we want to go through http
					[ ] e.g. resolve("graphql://localhost:4000/Gauze_Mutation") for a new protocol namespace
						[ ] ideally should be something like resolve("graphql://Gauze_Mutation.alexahn.com") or resolve("graphql://alexahn.com/Gauze_Mutation")
							[ ] having a DNS record per graphql type per subdomain seems like a burden, maybe we need to create an independent name service just for graphql?
								[ ] e.g. a host resolver at "graphql://alexahn.com" that will handle the path resolution for "Gauze_Mutation"
	[ ] schema stitching based on a name resolver
[x] create new tables and entities:
	[x] secret
	[x] session
	[x] proxy
	[x] agent_root
	[x] agent_account
	[x] agent_user
	[x] agent_person
	[x] agent_character
[x] login generalized across all agents according to assert, request, verify, login flow
	[x] src/environment/models/agent_root
	[x] src/environment/models/agent_account
	[x] src/environment/models/agent_user
	[x] src/environment/models/agent_person
	[x] src/environment/models/agent_character
[x] authentication flow
	[x] jwt for each realm
	[x] jwt payload is the store for agent information
	[x] signup
	[x] create anonymous session to handle authentication
		[x] assert person email
		[x] verify account password
	[x] enter session for non null agent
	[x] exit session
	[x] signout
[ ] bring back reality realm?
	[x] separate sessions for different realms
[x] change src_from_base to use the entities defined in the kernel for internal entities
[x] update kernel stages to use new entities
[x] add agent_types field to method definitions for abstract entities (should be an array value of allowed agent types)
	[x] we can only do this if we change the interpretation of public to mean public inside an authenticated session
		[x] we probably have to do this because the root whitelist and blacklist are invalid without a valid session
			[-] not necessarily since a null agent id and agent type means that anyone can update or change the entity
				[-] to do this, we have to change agent_id and agent_type to be nullable in whitelist and blacklist, which seems like a pain
	[x] change system interface to reject non authenticated users
	[x] harden all agent type checks
[x] set up environment interface, controllers, and models
	[x] barebones piping to get the graphql mutations working
[x] fix class names generated from code (there is an underscore)
[x] put all auth functions into a central location so it is easy to use
	[x] should be a simple interface: authenticate(req) -> agent
[x] update delete methods to delete relationships in kernel database model
	[x] also delete whitelist and blacklists associated with the entity
[-] think about whether or not we want to make all associations to agent root instead of proxy root for sessions and secrets
	[-] it allows a simpler authentication architecture since we can change the jwt audience for the proxy session to be environment
	[-] but it causes more indirection in environment controllers because we need to use the agent root instead of proxy root
		[-] we could just add agent_root_id to the jwts
	[x] maybe not, because proxy has to be a system audience/realm authentication so that we can query the system interface
		[x] e.g. if we want to display the available proxies
[x] update system to use the agent parsed from the jwt
	[x] update all tests to use the new agent structure
[x] refactor environment controllers to have a function that specifies the requirements to proceed (which is stored in session data)
	[x] make a method on session to augment the session data so that it all goes through one place
	[x] refactor all session data management to use something like "steps.person.assert.email.success", "steps.person.request.email.success", "steps.person.request.email.code", etc
		[x] set login conditions based on step definitions (e.g. an array of success values for steps: ["steps.person.assert.email.success", "steps.person.verify.email.success", "steps.account.verify.password.success"])
	[x] the code could be cleaner if we are willing to do be inefficient (e.g. group the data field modification and checking to also encompass doing a database query to grab the session row)
		[x] for now the pattern works, and it can be refined in the future so it's okay
[x] move guards outside of batch functions so that the errors are cleaner
	[x] system model
	[x] relationship model
[x] server application clean up
	[x] come up with a bare bones pattern to define url and routes
	[x] refactor the server application
[x] cached where in and cached where not in exposed to database graphql
	[x] value is a string key that is a key to a value in cache
	[x] hook up lru cache to system and database
[x] frontend setup
	[x] esbuild
	[x] eslint
[x] add count method to database and system kernel models
	[x] add count method to database kernel models and controllers
		[x] expose graphql method in database interface
		[x] expose graphwl method in system interface
[x] frontend architecture
	[x] state store
	[x] router
	[-] ui framework
		[x] tried material ui but didn't find it to be visually pleasing
		[x] semantic ui seems like it is a dying project so i don't want to use it again
		[x] trying out extreme minimalism by using browser primitives and basic styling
[x] minimalist frontend setup
	[x] entry point
	[x] esbuild command
	[x] http-server command
	[x] state management
	[x] package.json scripts updated to allow more convenient grouping
[x] authentication routes and flow for frontend
	[x] gauze environment client
	[x] data management for flow information
		[x] use the same requirements structure on the frontend
		[x] generalize the pattern so that new requirements can easily be added
		[x] instead of breaking out each requirement into a separate page, just make a component to handle it
[x] add a root level method to query for registered entities
	[x] call it _header
	[x] add to kernel stages
	[ ] update to pull the type names from interface definitions for attributes_query_type and attributes_mutation_type
	[x] add relationship data for each entry, which we can easily pull from structure definitions
[x] data presentation in ui
	[x] basic piping to fetch data
	[x] pagination record tied to view/url
		[x] read the record, which is an array of primary key ids
		[x] map to items from the local store
	[x] table ui with filters and sorting
[x] store jwts in local storage
	[x] clear jwts when jwts expire
[x] update headers method to return field definitions
	[x] align header response type to look like the abstract definition as much as possible
[ ] build an admin management react app to dog food the interface
	[x] list view for entities the agent can access
	[x] item view for an entity the agent can access
	[x] create a new entity
	[x] update an entity
	[x] delete an entity
	[x] show relationships for entity item
	[ ] add a command to set an agent as an admin for an agent type
		[ ] should just update the project configuration file
	[x] src/gauze.json
		[x] track admin users by having a field in src/gauze.json called managers or admins that holds the agent root ids
			[x] use the config from kernel system model to bypass authorization checks if the agent id is one of the managers
			[x] the config will have to be split by environment and agent type
			[x] this approach seems better than creating a table in sql because the set of managers is in source control
		[-] track entities by using the project and gauze fields?
			[x] the entities can just be parsed from $abstract, so maybe just create a method that returns a set of entities
[ ] data integrity guards and system integrity constraints
	[x] prevent agents from being deleted by removing delete whitelist in signup logic
		[x] the root object tied to a session should not be able to be deleted
	[ ] add column length information to fields so that we can also display an input field of the same size
		[ ] ideally we want to parse this data from the migration files, but we can require the user to provide it in the abstract definition
		[ ] maybe abstract this and allow sizing functions to be defined in $abstract
	[ ] type naming constraints
		[ ] cap table name to 255 characters
		[ ] cap graphql type name to 255 characters
		[ ] align name lengths with sql column limits for all types
			[ ] entity_type, agent_type, realm, agent_role, etc
	[ ] think about some defensive programming strategies to handle the lack of one to one constraints and other similar structural ambiguities
		[ ] we might need to specify one to one relationships via structures
		[ ] constraint checking might be best done by creating a projection of counts for relationships because we need a data structure that is indexed on counts
			[ ] maybe a simple aggregation table that has from_type, to_type, from_id, count
				[ ] probably need to use something else that is commutative at the outer layer to avoid transactions locking too much?
					[ ] would be kind of a pain to lose transactional certainty and have to manage synchronization between two data sources
					[ ] just shard the table
				[ ] will probably need another aggregation table per item, that has the total count of relationships (to any entity) on the item
	[ ] email serializer to lowercase (or use a graphql scalar type)
	[x] copy agent creation operations and remove delete whitelist for environment sign up
		[x] creating an agent was broken because it needed the create whitelist
[ ] abstract entity and field definition extensions (aligned with database semantics)
	[ ] add min and max value to field definitions
		[ ] we would need to choose whether or not we act on pre-parsed values or parsed graphql types
		[ ] would also need to include a comparison function that would need to be defined in $abstract
	[x] add allowed_agent_types definitions to individual fields
		[x] filter returned fields according to agent type
		[x] update manager to enforce new constraints
	[x] add default order key to entity definitions
		[x] update entity definitions to add default_order and default_order direction
		[x] update migrations to add index on created_at, updated_at, deleted_at
	[x] add an indexed attribute to fields in abstract entity definitions
		[x] update entity definitions to add indexed to field properties
		[x] only allow ordering and where selection on fields that have indexed set to true
		[x] ideally this setting should align with a database index
			[x] not enforced but should be documented
[ ] query and mutation argument extensions (aligned with database semantics)
	[ ] add where_greater and where_lesser
	[x] add where_between
	[x] add where_like
	[ ] consider changing order to accept an array of ordering arguments (e.g. column and direction)
		[ ] the problem is that it would be a pain to handle in the ui because the order in which the sorts are applied matter
		[x] for now, let's keep it simple and stick to only one sort order
	[x] act on source for create methods to also create a relationship
[x] header data expansion and entity definition display in ui
	[x] include relationships and method policies
[ ] ui, design language and visual consistency
	[ ] figure out the general structure of layouts and sections
		[ ] configure all the styles from the root node and downwards in a consistent manner
	[ ] ui forms
		[x] item route for read, update, and delete
		[ ] maybe use something like zod for input validation
	[ ] general graph traversal ui
		[x] pannable and zoomable
		[x] relationship representation and traversal
			[x] filter results by parent/child
			[x] creating items in a table should also create a relationship tied to the parent/child
			[x] x button to close a table
			[-] paginating a table should show parent/children for the current set of results and hide the others?
				[x] just keep showing the node even though it may not have any relationships to the parent results
		[x] connection component to track where to draw svg paths
			[x] connection initialization to set coordinates
			[x] piping to enable connections to be defined
			[x] fix connection updates so that the parent gets the source connections
			[x] update connection definition to include component and props
			[x] proper initialization order
			[x] update connection coordinates on pan, zoom, and scale
				[x] zoom is currently just forcing a recalculation of coordinates, which sometimes makes the ui look weird
				[x] look into a discrete function to calculate new coordinates on zoom
		[ ] edge component to draw svg paths
			[x] use connection coordinates to display an svg element
			[ ] update edge definition to include component and props (which render at the center of the path)
		[x] refactor all graph ui code to follow a strict state management, synchronization, and rendering lifecycle
			[x] fix ui bugs that cause panning and zooming issues after changing routes
		[x] disable flexbox wrap for graph tables
			[x] causing weird issues when resizing the window
		[x] service synchronization loop
			[x] set it up in the root component
		[x] parallelize initialization of nodes and connections
			[x] takes too much time when the number of nodes and connections goes up
			[-] new state variable to track when things are initializing
				[-] when there are no more things initializing and the state is toggled, then we untoggle it and sync from service
				[x] parallelized all initiation so we don't need to keep track of any order
		[x] expose source field to system interface
		[-] it is ideal to have a mapping from the raw data to the presentation but it doesn't seem possible because the interface introduces a semantic layer
			[-] it seems the core data to represent the ui will be things that represent objects in the interface (e.g. a table)
			[-] because it is not possible to go from the raw data to the presentation, it seems there is no point in having a flat presentation layer (e.g. aggregating all the data in one place)
				 [-] the objects that represent the interface will render objects that themselves hold a tree of things inside
					[-] it makes the visual model hierarchy kind of ugly because things are not normalized at the highest level, but the logic of handling relationships and so on is made much simpler because they are handled in a relative manner
			[x] the browser limitations of rendering elements in arbitrary positions prevents us from using a tree to render objects in arbitrary positions because the parent element must always have a dimension greater than the children
				[x] the only way to allow a child element to be moved anywhere is to grow the dimensions of the parent to the entire viewport, but this causes issues with event handling
					[x] it is probably possible to set up an elaborate event naming scheme so that we can handle mouse clicks through all the layers but i've opted to flatten the ui for now
		[x] performance refactoring
			[-] refactor graph ui to use render service to store data
				[x] refactored graph ui to use graph service to store data
			[-] set up subscriptions per node
				[x] set up a main synchronization loop at the root
			[-] maybe we can avoid using the render service if we can throttle the state updates
				[-] useCallback with a throttled state update on subscription changes (maybe per 100ms)
			[ ] find a way to skip mouse event registration if it has already been done (instead of setting up and tearing down on every render)
			[-] dynamically reduce the number of dom elements based on z scale by snapshotting the presentation into a canvas element
				[-] use the canvas snapshot when the z scaled element crosses a scaling threshold
			[-] dynamically reduce the number of dom elements based on visibility by snapshotting the presentation into a canvas element
				[-] use the canvas snapshot when the element is outside the viewing area
			[x] memoized states by timestamp or last changed
				[x] graph service should have a memoized interface
					[x] set up a basic cache system for activeNodes, activeConnections, activeEdges methods
				[x] cpu usage should be close to zero when doing nothing even with a low interval rate
			[x] tried to do visual memoization via rasterization and snapshotting rendering to canvas, but it was too hacky
			[x] memoize node based on props instead and lean on react to handle rendering
		[x] sharing links or structured identifiers for loading in pieces of data
			[x] drag and drop linking to create relationships once the item is loaded
			[ ] editing links to manage relationships between entities
		[x] whitelist and blacklist management
			[x] show whitelist and blacklist entries for items
			[x] convenient way to manage access control via the graph ui
				[ ] add a way to verify the integrity of agent ids before creating whitelist or blacklist entries
					[ ] maybe some button from the root graph ui that allows someone to generate a signed message that represents the agent, and a button to verify a signed message
		[x] extend type item view to be able to view relationships to the object
		[x] load relationships from server
			[x] extend relationship read query to be able to accept an array of from entity ids and to entity ids
		[x] editing mode for the entire graph
			[x] show and hide button to close a table based on editing mode
			[x] show and hide buttons to create and delete relationships based on editing mode
		[ ] personal description for table
			[ ] or allow them to rename the title
	[x] rename color scheme variables to use numbers
	[ ] a minimum design language
		[x] fonts
		[x] colors
		[x] shapes
		[ ] interactivity
	[x] color the graph ui using the minimum design language
	[x] make parent visible from table (to know which relationship the table is representing)
		[x] add from and to identifier information to top left corner of the table
		[x] highlight edges that represent the nested relationship by changing their color to red
	[ ] figure out how to handle z-index for relationship spans (so that the edges don't overlay the span)
	[ ] update pagination to use chevron icons instead of carrots
	[x] add hover classes to indicate interactive elements
	[ ] add active classes to indicate interaction consequence
	[x] interaction guards for strict run state management
	[x] local storage for graph
	[x] change default route after proxy login to be root
	[x] style the environment pages (sign in, sign out, sign up)
	[ ] workspaces
		[x] allow custom workspaces to be created
		[ ] allow custom workspaces to be shared
		[x] navigable by either menu on left side of screen or bottom of screen
		[x] home workspace is the entry point
			[ ] have an easy way for agents to store custom workspaces (e.g. a workspace entity that is automatically connected to the agent entity)
		[x] use local storage and have a new route structure
			[x] routes will only resolve due to local state, so if someone were to open the url in a brand new browser, it will fail
				[x] this is fine, they should just copy and paste the workspace data they manage manually (e.g. stored into a workspace entity)
		[x] create new orchestrate methods to deal with spaces
		[x] create new graph methods to deal with spaces
		[x] change spaceActiveEdges to filter by active entities
		[x] fix creating relationships (currently crashing)
		[x] clean up dead orchestrate and graph methods
		[x] capability to rename a workspace
	[ ] figure out how to handle spacing out initialization events in purely synchronous code
		[ ] probably need to use setTimeout
	[ ] display an error message inside the table if an agent does not have permission to view
		[ ] use an error boundary?
	[x] test usage in non-private browser tab
		[x] see if the memory usage becomes a problem for long sessions and if reloading the app in another tab makes it re-useable
		[ ] not noticing any noticeable performance degradation so far
	[ ] use local data for initial render if possible
		[ ] re-implement soundness and completeness (or maybe just one of them)
		[x] minimal local data loading for graph routes
			[ ] test edge cases where data is not fully formed
				[ ] should be impossible because we are only updating the graph data with fully formed data?
		[x] rearchitect session management to be only jwt based before relying on local data for rendering
	[x] reorganize synchronization logic to be done from the entry point
	[x] add synchronization for model service
	[ ] app icon svg
	[x] move static directory to inside of src and define a dataurl loader for svg
	[x] look into and fix edges not rendering correctly in non-private tab
	[x] using blur and focus seem to be unreliable for handling state synchronization across tabs
		[x] page visibility api is only helpful when dealing with tabs, not windows
		[-] using a crdt could work, but it is probably overkill
			[x] try to see if there is a way to make the blur and focus more reliable?
				[x] seems to be okay if we properly act on cleared intervals?
	[x] change update fields to use graph methods to update service state, and don't use a local state in the table component
		[x] this will allow state to properly propagate between windows/tabs
	[x] fix filter fields not syncing across tabs
	[x] fix date input not parsing changes correctly
	[-] change created_at, updated_at, deleted_at to use a regular input field instead of a datetime input field because they cannot be defined via a datetime input due to the time granularity
		[x] there is no point because like does not work with date type in sqlite
	[x] update input field columns to be twice as wide as they are currently so that datetime field can display the time portion
	[x] update input field component to manually modify the dom element value on a hard sync (this is because we can't use a controlled component for date input)
	[x] add new filter modes
		[x] search (where_like)
		[x] range (where_between)
	[ ] prevent tab from repositioning the view
	[x] reinitialize connections when entering and exiting link edit mode
	[x] collapse reload queries into one query by using nodeID as the query name
	[ ] add timestamp to every model record (to enable conditional data loading based on freshness)
	[ ] flush old sessions from model collection periodically
	[ ] investigate fetch issue (seems to take over a second for a non-private tab)
		[ ] in a private tab, the latency displayed in the network tab aligns with the timestamps in console.logs
		[ ] in the public tab, the latency for the graphql query is 30ms, but it takes fetch over a second (1000ms) to resolve
	[x] fetch headers from root system state
	[ ] generalize query squashing by using data loader (and also hook up ttl caching)
[ ] naming, organization, error consistency and code quality
	[x] rename valid_agent_types in abstract definition to allowed_agent_types
	[x] refactor validate_entity_config to use dot path for error messages
		[x] use the same pattern as defined in the environment session model to validate data fields
	[ ] use types defined in abstract realm for all environment graphql definitions
	[ ] rename src/kernel/src/initial to src/kernel/src/skeleton
	[ ] refactor kernel models to have elegant function signatures
		[ ] should probably group things together to have better conceptual clarity instead of abusing positional arguments
	[ ] naming convention refactor (update according to all rules)
		[x] double underscore for module namespacing hierarchy
		[ ] only use upper snake case for global constants and module exports (convert in function const to lower snake case)
	[ ] add a _description attribute to every module so that the codebase can be explored via the repl
		[ ] always add the field at the end of every module definition so it shows up at the bottom in the repl
	[x] rename rud protected middleware to ud protected middleware or (updated_delete_protected_middleware)
	[x] eslint
	[ ] errors directory per realm
		[ ] realms can have their own custom errors, but only for the particular logic they are handling
			[ ] in all other cases, we should just bubble up the error from below
		[ ] use GraphQLError from the graphql module to supply an extensions property
	[ ] think about how to do field validation so that field errors can be abstracted
		[ ] currently we will just throw hand crafted errors, but we could probably have a structured approach
	[x] change var to const where we can
	[ ] figure out how to get stack traces from dataloader, or design the program in such a way that nothing inside the dataloader function can fail
[ ] graphql entity types and system integration
	[ ] add field to abstract entity definition to exclude from graphql interface
		[ ] unless we specify the realm, we can't do this without also excluding from the database graphql interface
			[ ] then the linker has to take in a realm parameter
	[ ] add field to abstract entity fields to exclude from graphql interface
		[ ] we can't do this without also excluding the field from the database graphql interface
		[ ] we can't do this without causing a fork in the attributes definition for an entity, which would be annoying since it is an additional thing to remember
			[ ] e.g. prefixing the graphql attribute types with the realm name
	[-] use graphql enum types (https://graphql.org/graphql-js/type/#example-4) to lock down fields that act on a set of values
		[-] entity_type, agent_type, realm, agent_role
		[x] the problem is that using the enums is a pain because you need to know the name of the option
			[-] we can introduce a naming convention, e.g. REALM__SYSTEM, AGENT_ROLE__ROOT, AGENT_ROLE__TRUNK, AGENT_ROLE__LEAF, etc
				[x] but it is still awkward, and it feels like it would be easier to use if we just left it as a string field but added validation on it
			[ ] add custom validation for string types that accept a set of values
	[x] add a required attribute to fields in abstract entity definitions?
		[x] we can use it to create two different attribute types
			[x] one for attributes (creating, updating and the returned attributes), and another for where (filtering)
			[x] we cannot do partial updates if we do this, and all updates will require the full set of attributes
				[x] if someone wants partial updates, they can loosen the constraint and define custom validation in the models or controllers
		[x] name the current attributes to something like Ezuag_Mutation__Where, along with the other types for where_in, where_not_in, cache_where_in, cache_where_not_in
		[x] define new utility functions
		[x] add new properties to abstract entity definitions using the new utility functions
		[x] create new graphql structures to align with the new properties
		[x] update header graphql query to return the new properties
		[x] remove graphql_fields from entity definition
	[ ] test custom abstract types/scalars
		[ ] see how easy it is to use third party scalars and how the error messages present themselves
[ ] cli, commands, and manager application
	[ ] polish commands and manager application
	[x] align environment variables with cli commands
		[x] ideally have every parameter for a cli command have an equivalent env variable namespace
	[ ] add gauze.json as a config file for the gauze cli (which will keep track of gauze version and admin users)
		[ ] add validation for gauze.json to ensure that particular fields exist
	[ ] commands
		[ ] read project
		[ ] update project
	[-] have read command manually construct a list of files and directories and intersect with the results from find
		[x] kind of problematic when we just use find because an entity might contain another entity's name inside it
			[x] e.g. hello_entity and hello_entity_world
		[x] use extended regex to enforce exact file name match by prefixing the pattern with / and ending with the file suffix
	[ ] look into doing ast parsing and some table management data structures to programmatically generate migration files
	[ ] cli command to add a new method to an existing entity
	[ ] load in all project entities before running any command to verify the integrity of every entity definition
	[ ] command to generate human readable graphql schemas
[ ] system design
	[ ] soft delete
		[ ] stringified javascript dates are utc, but the dates generated by new Date() use the system clock
	[ ] change uuid to ulid
		[ ] validate id field to ensure ulid structure
		[ ] not sure we want to do this because the key encodes time information
			[ ] which will seep into the sharding design
			[ ] do we want to shard by chronological order?
			[ ] it has some interesting qualities, in that you would be able to provision servers ahead of time for a frame of time
				[ ] might make operations easier because the conceptual model is simple, basically a tape
	[ ] rate limiter
		[ ] by route, by ip, by account, by location, etc
	[ ] file entity
		[ ] file handler entity
			[ ] manages an io entity that can read and write
		[ ] streaming interface for files
	[ ] process entity
		[ ] input and output architecture
	[ ] monolithic foundation
		[ ] source/version control system
		[ ] build system
		[ ] email
	[ ] session management and authentication flow
		[ ] refresh session method
		[ ] add _metadata to environment mutation responses?
		[x] treat sessions as actual sessions and verify that every jwt exists in the database
			[-] verify_session method in the environment session model
				[x] add a function to src/environment/authenticate.js
			[x] configure the environment kernel model to use dataloader?
				[-] might need atomic guarantees so maybe we shouldn't
				[x] if we want dataloader for the environment, we need the controller/agent to pass in a unique seed for some of the methods (e.g. creating a null session)
					[x] it seems the controllers are already generating ids for everything they touch
				[x] add dataloader but make a note that we need to write tests for it later to catch any session hijacking scenarios during either sign in or sign up
					[x] as far as i can tell, it should be okay because we are generating the session id prior to interacting with the model
	[ ] whitelist / blacklist symmetry?
		[ ] should whitelist also only apply at leaf level? currently blacklist only applies at leaf level
	[ ] granular dataloader cache clearing based on record (nice to have)
		[ ] e.g. if we update a record, it should only clear the cache for all read operations on the record
		[ ] will need to add a new data structure to the lru cache we implemented to keep track of operation association with records
			[ ] e.g. parse the parameters and construct a tree
	[x] update all cache lifetimes to 8192 milliseconds
	[ ] map reduce and data sharding
		[ ] map reduce for tracing garbage collection
			[ ] the initiation is based on the shard of data that a node is responsible for
				[ ] e.g. mapping the from reference to the to reference
			[ ] there will need to be some mapping nodes that accept the mapped values to reduce them
			[ ] ultimately at the end, we want a set of root ids for each document
		[ ] dynamic number of mappings and reductions according to the length of the cycle
			[ ] would be ideal if we had a static number, but we don't have a way to prevent cycles from forming
		[ ] the problem is that the final commit has to be done atomically, so all the changes would need to be aggregated to one node
			[ ] feels like this could be a bottleneck
				[ ] not really? it's just a set of ids, so we can increase the frequency of the garbage collection if the set is growing too large
					[ ] i don't imagine that the set of ids should be over a million, and a million identifiers is nothing for a single server
			[ ] if we give up consistency then we can have partial commits, but it complicates the data integrity picture
	[ ] turn kernel into a proper stack
		[x] kernel/controllers/class.js
		[x] kernel/models/class.js
		[ ] kernel/interfaces
			[ ] manage cache, logging, shell, infrastructure, etc
		[ ] provide a map reduce interface from the kernel, and use the interface from the database realm or system realm
		[-] allow connecting repl to a live system?
			[x] i'm mostly against this idea because it increases the surface area of the interface, and subsequently security risks
				[x] i think there should only be one interface
	[x] rename the relationships field to "to" or "relationships_to", add a new field called "from" or "relationships_from" to allow bidirectional navigation of relationships
		[-] will need to add a "child" field to mirror the metadata proxying we do with the "parent" field
			[x] just add an extra field called direction instead of creating a new field
		[x] add source argument for database graphql methods that also contains the relationship direction
		[x] refactor the kernel database model to use the new source argument
		[x] delete the old relationships field
	[ ] add a field called transaction_id (or request_id) to allow busting the cache for segments of a query or mutation?
	[ ] create a system entity
		[ ] create a record for every valid server by registering the mac address and cryptographically signing the record using a root certificate
			[ ] each record should also have a public key for the individual server
				[ ] a server can verify it is who it says it is by signing any requested message
			[ ] the private key for the server should only live on the server and should be made at the same time as registering the server
				[ ] there should be no elevated privileges for someone who gains access to the private key, it is mostly used for organizing network topology
				[ ] or we can create an agent for every server, and create a secret only the server can access
					[ ] either store the secret to authenticate on the server or set up automatic session refreshing
					[ ] feels like it might be abusing the concept of an agent though
		[ ] top down certificate system, add a cli command to generate the root private key (and certificate)
			[ ] eventually we want to tie every server to a resolvable name address and mirror the certificate structure of the domain name
		[ ] add an environment variable for the root public key, or add it as a file in a predefined path
		[ ] virtual machine development environment to test multiple systems running at the same time
			[ ] precursor work for setting up sharding since we need a way to load in configuration information for each server
		[ ] investigate neural network architecture for subquery resolution
			[ ] metadata needs to be stored somewhere
	[ ] create file entity
		[ ] name (string)
		[ ] size (integer)
		[ ] parts (array of strings)
	[ ] create part entity
		[ ] file (string)
		[ ] identifier (string)
		[ ] number (integer)
		[ ] size (integer)
		[ ] io (string)
	[ ] create io entity
		[ ] system (string)
		[ ] size (integer)
	[ ] kernel observability methods
		[ ] fs.statfs for disk space (required)
		[ ] some non-obtrusive way to get processor and memory utilization (nice to have)
	[ ] change authentication to specify the realm it is authenticating to so we can add kernel sessions
		[ ] e.g. environment { enter_session { environment } }
		[ ] e.g. environment { enter_session { system } }
		[ ] e.g. environment { enter_session { kernel } }
		[ ] add a field to gauze.js that includes a section for people who can access the kernel interface
			[ ] we can add allowed_realms to proxy entity if we want to store it in the database (or a binary field for every realm)
				[ ] read only access to proxy entity for agents (currently the unique constraint is preventing people from spoofing other users)
			[ ] agents that can access the kernel interface should be deployment environments (e.g. development, staging, production) and infrastructure engineers
	[ ] relationship interfaces
		[ ] update relationship to be able to act on source?
			[ ] should be able to enable a query like: read_entity { relationships_to { read_relationship() { } } } or read_entity { relationships_from { read_relationship() { } } }
				[ ] the current relationship methods seem kind of a pain to interact with, it would be ideal to be able to get a list of relationships immediately with entity queries
		[ ] update relationship to be able to handle where_in and where_not_in?
		[ ] update relationship with count method
		[ ] rethink and refactor all of relationship interface to align expectations with entity interface (if possible)
			[ ] the problem is that relationships are the bridge between types so the access control logic becomes very complex
	[ ] pgp or user level jwt for signing payloads that can be shared with other users to verify identity
		[ ] need a way to share agent identifiers to allow whitelist and blacklist management
			[ ] kind of problematic for blacklist though because people cannot be blacklisted if they don't share their identifier?
				[ ] maybe we need a user level identifier and a system level identifier?
				[ ] might need to add a method to get the owner for something
	[ ] implement time sharing scheme to track how much time an agent uses
		[ ] rate limit based on time share
	[ ] create tag entity
		[ ] allow agents to tag entities
[ ] unknowns, abnormal behavior, and investigations
	[ ] look into why router5 doesn't seem to be able to uri encode correctly
		[ ] manually encoding and decoding seems to work
	[x] figure out why where query on json date values doesn't work
		[x] probably a mismatch between the value expected in the database and the one provided by the interface
		[-] the dataloading is coercing all datatypes to json, so we need to do the serialization inside the dataloader
			[-] move the serialization logic from the controllers to the models
			[x] use the cache to store the parsed input
		[x] do pre serialization and middleware parsing for where on update and delete methods
		[x] figure out if we want to do the same thing for the system model and interface
			[x] it might not be necessary because the inputs to the system are expected to be able to be serialized to json
			[x] the system model just executes a graphql operation, so it doesn't need the parsed arguments
[ ] server side rendering bindings and architecture (nice to have)
	[ ] either local storage binding or service binding (e.g. mirror the model service on the backend)
	[ ] put redux state into local storage or put model data into local storage
	[ ] inject the react output into an index.html template (that has the app script and css tags)
		[ ] this will cause a re-render on the client side that will essentially repeat the entire rendering logic after receiving the initial html from the server
			[ ] if done correctly, the visual appearance of the page should not change at all, even though there was a client side re-render
			[ ] the extra render should not impose a heavy server hit because all the graphql queries should still be in the lru cache
[ ] networking, and load balancing based on source ip
	[ ] same principle as database sharding
	[ ] look into bgp to handle destination routing and configuring autonomous systems
		[ ] probably define an autonomous system for every datacenter
[ ] dogfood the framework by creating a project that parses the source code of the framework into a navigable ast (maybe)
	[ ] see how well relationships work in representing abstract data structures
	[ ] build a canvas ui
	[ ] bring the project into the kernel as a source code visibility tool, which can maybe later become a representation layer for source control
		[ ] it would be nice if gauze could be an all in one solution for creating an organic self-contained system (from code to presentation)
			[ ] we would need to build the monolithic base of the system to use the core data storage to host the source code
[ ] better tests
	[ ] relationship tests need to actually test that subsets of things can get acted on correctly
		[ ] imagine if the program misinterprets the method as not being a relationship method, and we need to catch that it acted on the wrong set of items
[ ] look into deno, bun, etc
[ ] start thinking about making a build system
[ ] documentation for cli and entity definitions
[ ] commit the gauze spa files to the repo and serve it via the server application

[ ] custom gauze parsers
[ ] realm level auth
	[ ] specified in entity definitions
[ ] http middleware
[ ] process middleware
[ ] closed and open project modes
[ ] routing pattern
	[ ] modular applications/realms
[ ] server side rendering
	[ ] env variable parsing for stores
	[ ] write project documentation using server side rendering
